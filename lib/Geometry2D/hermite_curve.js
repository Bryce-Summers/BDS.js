// Generated by CoffeeScript 1.11.1
(function() {
  BDS.Hermite_Curve = (function() {
    function Hermite_Curve(pt1, tan1, pt2, tan2, input_coefs) {
      if (input_coefs !== void 0 && input_coefs === true) {
        this._A = pt1.clone();
        this._B = tan1.clone();
        this._C = pt2.clone();
        this._D = tan2.clone();
        return;
      }
      this._A = pt1.multScalar(2).sub(pt2.multScalar(2)).add(tan1).add(tan2);
      this._B = pt1.multScalar(-3).add(pt2.multScalar(3)).sub(tan1.multScalar(2)).sub(tan2);
      this._C = tan1.clone();
      this._D = pt1.clone();
    }

    Hermite_Curve.newFromBezier = function(c0, c1, c2, c3) {
      var pt1, pt2, tan1, tan2;
      pt1 = c0;
      pt2 = c3;
      tan1 = c1.sub(c0).multScalar(3);
      tan2 = c3.sub(c2).multScalar(3);
      return new BDS.Hermite_Curve(pt1, tan1, pt2, tan2);
    };

    Hermite_Curve.prototype.toPointsAndTangents = function() {
      return [this.position(0), this.tangent(0), this.position(1), this.tangent(1)];
    };

    Hermite_Curve.prototype.toBezierControlPoints = function() {
      var c0, c1, c2, c3, pt1, pt2, ref, scale, tan1, tan2;
      scale = 1.0 / 3.0;
      ref = this.toPointsAndTangents(), pt1 = ref[0], tan1 = ref[1], pt2 = ref[2], tan2 = ref[3];
      c0 = pt1;
      c1 = pt1.add(tan1.multScalar(scale));
      c2 = pt2.sub(tan2.multScalar(scale));
      c3 = pt2;
      return [c0, c1, c2, c3];
    };

    Hermite_Curve.prototype.subCurve = function(t1, t2) {
      var A_new, B_new, C_new, D_new, output, scale_a, scale_b, scale_c, scale_d, t1_2, t1_3, t2_2, t2_3;
      t1_2 = t1 * t1;
      t1_3 = t1 * t1 * t1;
      t2_2 = t2 * t2;
      t2_3 = t2 * t2 * t2;
      scale_a = -t1_3 + t2_3 - 3 * t1 * t2_2 + 3 * t1_2 * t2;
      A_new = this._A.multScalar(scale_a);
      scale_a = 3 * t1_3 + 3 * t1 * t2_2 - 6 * t1_2 * t2;
      scale_b = t1_2 + t2_2 - 2 * t1 * t2;
      B_new = this._A.multScalar(scale_a).add(this._B.multScalar(scale_b));
      scale_a = -3 * t1_3 + 3 * t1_2 * t2;
      scale_b = -2 * t1_2 + 2 * t1 * t2;
      scale_c = t2 - t1;
      C_new = this._A.multScalar(scale_a).add(this._B.multScalar(scale_b)).add(this._C.multScalar(scale_c));
      scale_a = t1_3;
      scale_b = t1_2;
      scale_c = t1;
      scale_d = 1;
      D_new = this._A.multScalar(scale_a).add(this._B.multScalar(scale_b)).add(this._C.multScalar(scale_c)).add(this._D);
      output = new BDS.Hermite_Curve(A_new, B_new, C_new, D_new, true);
      return output;
    };

    Hermite_Curve.prototype.position = function(t) {
      return this._A.multScalar(t).add(this._B).multScalar(t).add(this._C).multScalar(t).add(this._D);
    };

    Hermite_Curve.prototype.tangent = function(t) {
      return this._A.multScalar(3 * t).add(this._B.multScalar(2)).multScalar(t).add(this._C);
    };

    Hermite_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    Hermite_Curve.prototype.toPolyline = function(max_length_per_segment, times_output) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this.position(0);
      output.push(p0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.position(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.position(high);
        while (p_low.distanceTo(p_high) > max_length_per_segment) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.position(high);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return new BDS.Polyline(false, output);
    };

    Hermite_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    return Hermite_Curve;

  })();

}).call(this);

//# sourceMappingURL=hermite_curve.js.map
