// Generated by CoffeeScript 1.11.1

/*
Polyline class (also represents polygons)

Written by Bryce Summers on 1 - 4 - 2017.

Note: Closed Polylines are polygons...
 - So we will put all of our polygon code into this class.

Note: this class assumes that it contains at least 1 point for collision tests.

Note: Polyline <--> polyline intersection tests assume that the polyline is not self intersecting.

FIXME: Return proper point in polyline tests for complemented filled polylines.
 */

(function() {
  BDS.Polyline = (function() {
    function Polyline(_isClosed, points_in, _isFilled) {
      this._isClosed = _isClosed;
      this._isFilled = _isFilled;
      if (this._isClosed === void 0) {
        this._isClosed = false;
      }
      if (this._isFilled === void 0) {
        this._isFilled = this._isClosed;
      }
      this._points = [];
      if (points_in) {
        this.appendPoints(points_in);
      }

      /*
       * These are commented out to save memory for applications that don't need these.
      @_boundingbox = null
      @_lineBVH = null
      @_obj # Associated Obj.
       */
    }

    Polyline.prototype.appendPoints = function(array) {
      var j, len1, p;
      for (j = 0, len1 = array.length; j < len1; j++) {
        p = array[j];
        this.addPoint(p);
      }
    };

    Polyline.prototype.addPoint = function(p) {
      if (isNaN(p.x) || isNaN(p.y) || isNaN(p.z)) {
        debugger;
      }
      this._points.push(p);
      if (this._boundingbox) {
        this._boundingbox.expandByPoint(p);
      }
    };

    Polyline.prototype.removeLastPoint = function() {
      return this._points.pop();
    };

    Polyline.prototype.getPoint = function(index) {
      return this._points[index];
    };

    Polyline.prototype.size = function() {
      return this._points.length;
    };

    Polyline.prototype.isClosed = function() {
      return this._isClosed;
    };

    Polyline.prototype.isFilled = function() {
      return this._isFilled;
    };


    /*
    * http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/
    * Computes the area of a 2D polygon directly from the polygon's coordinates.
    * The area will be positive or negative depending on the
    * clockwise / counter clockwise orientation of the points.
    * Also see: https://brycesummers.wordpress.com/2015/08/24/a-proof-of-simple-polygonal-area-via-greens-theorem/
    * Note: This function interprets this polyline as closed.
     *  -> float
     */

    Polyline.prototype.computeArea = function() {
      var area, i, j, len, p1, p2, ref;
      len = this._points.length;
      p1 = this._points[len - 1];
      area = 0.0;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        p2 = this._points[i];
        area += (p2.x + p1.x) * (p2.y - p1.y);
        p1 = p2;
      }
      return -area / 2.0;
    };

    Polyline.prototype.isComplemented = function() {
      return this.computeArea() <= 0.0000001;
    };

    Polyline.prototype.ensureBoundingBox = function() {
      if (this._boundingbox === void 0) {
        this.generateBoundingBox();
      }
      return this._boundingbox;
    };

    Polyline.prototype.generateBoundingBox = function(polygon) {
      var j, len1, pt, ref;
      this._boundingbox = new BDS.Box();
      ref = this._points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        pt = ref[j];
        this._boundingbox.expandByPoint(pt);
        if (isNaN(this._boundingbox.min.x)) {
          debugger;
        }
      }
      return this._boundingbox;
    };

    Polyline.prototype.getBoundingBox = function() {
      return this._boundingbox;
    };

    Polyline.prototype.setAssociatedData = function(obj) {
      return this._obj = obj;
    };

    Polyline.prototype.getAssociatedData = function() {
      return this._obj;
    };


    /*
    getBVH: () ->
        return @_lineBVH()
     */

    Polyline.prototype.toPolylineSegments = function(output) {
      var i, j, len, p0, p1, ref;
      if (output === void 0) {
        output = [];
      }
      len = this._points.length;
      for (i = j = 0, ref = len - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p0 = this._points[i];
        p1 = this._points[i + 1];
        output.push(new BDS.Polyline(false, [p0, p1]));
      }
      if (this._isClosed) {
        p0 = this._points[len - 1];
        p1 = this._points[0];
        output.push(new BDS.Polyline(false, [p0, p1]));
      }
      return output;
    };

    Polyline.prototype._toLineSegments = function() {
      var i, j, len, line, output, ref;
      output = [];
      len = this._points.length;
      for (i = j = 0, ref = len - 1; j < ref; i = j += 1) {
        line = new BDS.Line(i, i + 1, this._points);
        line.p1_index;
        line.p2_index;
        output.push(line);
      }
      if (this._isClosed) {
        line = new BDS.Line(len - 1, 0, this._points);
        line.p1_index;
        line.p2_index;
        output.push(line);
      }
      return output;
    };

    Polyline.prototype.toRays = function(output) {
      var dir, i, j, len, p0, p1, ref;
      if (output === void 0) {
        output = [];
      }
      len = this._points.length;
      for (i = j = 0, ref = len - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p0 = this._points[i];
        p1 = this._points[i + 1];
        dir = p1.sub(p0);
        output.push(new BDS.Ray(p0, dir));
      }
      if (this._isClosed) {
        p0 = this._points[len - 1];
        p1 = this._points[0];
        dir = p1.sub(p0);
        output.push(new BDS.Ray(p0, dir));
      }
      return output;
    };

    Polyline.prototype.containsPoint = function(pt) {
      if (this._lineBVH) {
        throw new ERROR("Implement me Please!");
      } else {
        return this._point_in_polygon_test(pt);
      }
    };

    Polyline.prototype._point_in_polygon_test = function(pt) {
      var j, len1, odd, ray, segment, segments;
      ray = new BDS.Ray(pt, BDS.newDirection(1.0, 0));
      odd = false;
      segments = this._toLineSegments();
      for (j = 0, len1 = segments.length; j < len1; j++) {
        segment = segments[j];
        if (ray.detect_intersection_with_line(segment)) {
          odd = !odd;
        }
      }
      return odd;
    };

    Polyline.prototype.detect_intersection_with_box = function(box) {
      var polyline;
      if (this._boundingbox === void 0) {
        this.generateBoundingBox();
      }
      if (!box.intersects_box(this._boundingbox)) {
        return false;
      }
      if (this.isFilled() && this.containsPoint(box.min)) {
        return true;
      }
      if (box.isFilled() && box.containsPoint(this._points[0])) {
        return true;
      }
      polyline = box.toPolyline();
      return this.detect_intersection_with_polyline(polyline);
    };

    Polyline.prototype.detect_intersection_with_polyline = function(polyline) {
      var all_lines, intersector, lines1, lines2;
      lines1 = this._toLineSegments();
      lines2 = polyline._toLineSegments();
      all_lines = lines1.concat(lines2);
      intersector = new BDS.Intersector();
      return intersector.detect_intersection_line_segments_partitioned(all_lines);
    };

    return Polyline;

  })();

}).call(this);
