// Generated by CoffeeScript 1.11.1

/*

Intersector

Written by Bryce Summers on 1 - 2 - 2017.

features: Efficient Line Segment Intersection.
 */

(function() {
  BDS.Intersector = (function() {
    function Intersector() {}


    /*
    Calls the Line.intersect method on all intersecting lines.
    Does not treat lines that intersect at common points as intersecting.
     * takes arrays of BDS.Line objects.
    BDS.Line[] -> () [intersection sideeffects]
     */

    Intersector.prototype.intersectLineSegments = function(lines) {
      var event, event_queue, i, j, len, line, ref, sweepSet;
      event_queue = new BDS.Intersector.EventPQ(lines);
      sweepSet = new BDS.Intersector.LineSweepSet();
      len = event_queue.size();
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        event = event_queue.delMin();
        switch (event.type) {
          case BDS.Intersector.Event.ENTER:
            line = event.line;
            sweepSet.intersect_with_line(line);
            sweepSet.add(event.twin);
            continue;
          case BDS.Intersector.Event.EXIT:
            sweepSet.remove(event);
            continue;
        }
      }
    };


    /*
    Returns true iff there is at least one valid intersection detected in the input set of polylines.
    Does not treat lines that intersect at common points as intersecting.
    
    non_intersection_indices demarcate ranges of indices that should not be intersected against each other.
    Assumes that the indices are in rted order.
     */

    Intersector.prototype.detect_intersection_line_segments_partitioned = function(lines) {
      var event, event_queue, i, j, len, line, ref, sweepSet;
      event_queue = new BDS.Intersector.EventPQ(lines);
      sweepSet = new BDS.Intersector.LineSweepSet();
      len = event_queue.size();
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        event = event_queue.delMin();
        switch (event.type) {
          case BDS.Intersector.Event.ENTER:
            line = event.line;
            if (sweepSet.detect_intersection_with_line_partitioned(line)) {
              return true;
            }
            sweepSet.add(event.twin);
            continue;
          case BDS.Intersector.Event.EXIT:
            sweepSet.remove(event);
            continue;
        }
      }
      return false;
    };

    Intersector.prototype.intersect_line_segments_partitioned = function(lines) {
      var event, event_queue, i, j, len, line, ref, sweepSet;
      event_queue = new BDS.Intersector.EventPQ(lines);
      sweepSet = new BDS.Intersector.LineSweepSet();
      len = event_queue.size();
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        event = event_queue.delMin();
        switch (event.type) {
          case BDS.Intersector.Event.ENTER:
            line = event.line;
            sweepSet.intersect_with_line_partitioned(line);
            sweepSet.add(event.twin);
            continue;
          case BDS.Intersector.Event.EXIT:
            sweepSet.remove(event);
            continue;
        }
      }
    };


    /*
    Slower, but more robust version of intersect.
    Naive N^2 Intersection Algorithm.
     */

    Intersector.prototype.intersect_brute_force = function(lines) {
      var a, b, j, k, line1, line2, numLines, ref, ref1, ref2;
      numLines = lines.length;
      for (a = j = 0, ref = numLines; j < ref; a = j += 1) {
        for (b = k = ref1 = a + 1, ref2 = numLines; k < ref2; b = k += 1) {
          line1 = lines[a];
          line2 = lines[b];
          if (line1.points !== line2.points) {
            line1.intersect(line2);
          }
        }
      }
    };

    Intersector.prototype.intersect_brute_force_partitioned = function(lines) {
      var a, b, j, k, numLines, ref, ref1, ref2;
      numLines = lines.length;
      for (a = j = 0, ref = numLines; j < ref; a = j += 1) {
        for (b = k = ref1 = a + 1, ref2 = numLines; k < ref2; b = k += 1) {
          lines[a].intersect(lines[b]);
        }
      }
    };

    return Intersector;

  })();


  /*
  Event Priority Queue methods.
   */

  BDS.Intersector.EventPQ = (function() {
    function EventPQ(lines) {
      var enter, events, exit, i, j, len, line, p1, p2, ref;
      events = [];
      len = lines.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        line = lines[i];
        enter = new BDS.Intersector.Event();
        exit = new BDS.Intersector.Event();
        p1 = line.p1;
        p2 = line.p2;
        if (p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y)) {
          this._populateEvent(enter, exit, p1, p2, line, i);
        } else {
          this._populateEvent(enter, exit, p2, p1, line, i);
        }
        events.push(enter);
        events.push(exit);
      }
      this.PQ = new BDS.Heap(events, BDS.Intersector.Event_Comparator);
    }

    EventPQ.prototype._populateEvent = function(enter, exit, p1, p2, line, id) {
      enter.type = BDS.Intersector.Event.ENTER;
      exit.type = BDS.Intersector.Event.EXIT;
      enter.x = p1.x;
      enter.y = p1.y;
      exit.x = p2.x;
      exit.y = p2.y;
      enter.line = line;
      exit.line = line;
      enter.id = id;
      exit.id = id;
      enter.twin = exit;
      return exit.twin = enter;
    };

    EventPQ.prototype.delMin = function() {
      return this.PQ.dequeue();
    };

    EventPQ.prototype.isEmpty = function() {
      return this.PQ.isEmpty();
    };

    EventPQ.prototype.size = function() {
      return this.PQ.size();
    };

    return EventPQ;

  })();

  BDS.Intersector.Event_Comparator = function(e1, e2) {
    if (e1.line === e2.line && e1.type === e2.type) {
      return true;
    }
    if (e1.line === e2.line) {
      return e1.type === BDS.Intersector.Event.ENTER;
    }
    if (e1.x < e2.x) {
      return true;
    }
    if (e1.x > e2.x) {
      return false;
    }
    if (e1.y < e2.y) {
      return true;
    }
    if (e1.y > e2.y) {
      return false;
    }
    if ((e1.type === BDS.Intersector.Event.EXIT) && (e2.type === BDS.Intersector.Event.ENTER)) {
      return true;
    }
    if ((e1.type === BDS.Intersector.Event.ENTER) && (e2.type === BDS.Intersector.Event.EXIT)) {
      return false;
    }
    if (e1.id <= e2.id) {
      return true;
    }
    return false;
  };

  BDS.Intersector.LineSweepSet = (function() {
    function LineSweepSet() {
      this.heap = new BDS.Heap([], BDS.Intersector.Event_Comparator);
    }

    LineSweepSet.prototype.add = function(event) {
      return this.heap.add(event);
    };

    LineSweepSet.prototype.remove = function(event_to_be_removed) {
      var err, my_event;
      my_event = this.heap.dequeue();
      if (my_event !== event_to_be_removed) {
        err = new Error("ERROR: line_tuple exit ordering is messed up!");
        console.log(err.stack);
        debugger;
        throw err;
      }
      return my_event;
    };

    LineSweepSet.prototype.intersect_with_line = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref, results;
      len = this.heap.size();
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        results.push(input_line.intersect(line_crossing_sweep));
      }
      return results;
    };

    LineSweepSet.prototype.intersect_with_line_partitioned = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref, results;
      len = this.heap.size();
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        if (line_crossing_sweep.points === input_line.points) {
          continue;
        }
        results.push(input_line.intersect(line_crossing_sweep));
      }
      return results;
    };

    LineSweepSet.prototype.detect_intersection_with_line_partitioned = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref;
      len = this.heap.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        if (line_crossing_sweep.points === input_line.points) {
          continue;
        }
        if (input_line.detect_intersection(line_crossing_sweep)) {
          return true;
        }
      }
      return false;
    };

    LineSweepSet.prototype.detect_intersection_with_line = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref;
      len = this.heap.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        if (input_line.detect_intersection(line_crossing_sweep)) {
          return true;
        }
      }
      return false;
    };

    return LineSweepSet;

  })();

  BDS.Intersector.Event = (function() {
    Event.ENTER = 0;

    Event.EXIT = 1;

    function Event() {
      this.type = null;
      this.x = null;
      this.y = null;
      this.id = null;
      this.twin = null;
    }

    return Event;

  })();

}).call(this);
