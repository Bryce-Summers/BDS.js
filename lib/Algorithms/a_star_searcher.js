// Generated by CoffeeScript 1.11.1

/*

Written by Bryce Summers on July.11.2017

Abstracts high level A Star functionality.

-Base class for specific search strategies.

Requires the use of data nodes n that have three fields availible:
    v.dist_to_start = Infinity
    v.dist_to_goal  = Infinity
    v.previous      = null

    We will reference this as the Node type.
 */

(function() {
  BDS.SearchGraph = (function() {
    function SearchGraph() {}

    SearchGraph.prototype._error = function() {
      return console.log("Implement Me in A* child classs!");
    };

    SearchGraph.prototype.heuristic = function(loc, goal) {
      return this._error();
    };

    SearchGraph.prototype.neighbors = function(node) {
      return this._error();
    };

    return SearchGraph;

  })();

  BDS.AStarSearcher = (function() {
    function AStarSearcher(search_graph) {
      this._search_graph = search_graph;
      this._node_set = new Set();
    }

    AStarSearcher.prototype.setSearchGraph = function(search_graph) {
      return this._search_graph = search_graph;
    };

    AStarSearcher.prototype.a_star_search = function(start_node, end_node) {
      var frontier, goal, i, j, len, len1, n, neighbors, new_dist, node, node_path, pts, start;
      start = start_node;
      goal = end_node;
      this._node_set.add(start);
      this._node_set.add(goal);
      start.dist_to_start = 0;
      start.dist_to_goal = this._search_graph.heuristic(start, goal);
      goal.dist_to_goal = 0;
      frontier = new BDS.Heap([start], function(a, b) {
        return a.dist_to_start + a.dist_to_goal <= b.dist_to_start + b.dist_to_goal;
      });
      while (frontier.size() > 0) {
        node = frontier.dequeue();
        if (node === goal) {
          node_path = this._tracePathBack(node);
          this._clearNodeSearchData();
          pts = [];
          for (i = 0, len = node_path.length; i < len; i++) {
            node = node_path[i];
            pts.push(node.position.clone());
          }
          return pts;
        }
        neighbors = this._search_graph.neighbors(node);
        for (j = 0, len1 = neighbors.length; j < len1; j++) {
          n = neighbors[j];
          new_dist = node.dist_to_start + 1;
          if (new_dist < n.dist_to_start) {
            n.dist_to_start = Math.min(n.dist_to_start, node.dist_to_start + 1);
            n.dist_to_goal = this._search_graph.heuristic(start, goal);
            n.previous = node;
            frontier.add(n);
            this._node_set.add(n);
          }
        }
      }

      /*
      console.log("WARNING: No Path was found between ")
      console.log(start)
      console.log(" and ")
      console.log(goal)
       */
      this._clearNodeSearchData();
      return [];
    };

    AStarSearcher.prototype._tracePathBack = function(node) {
      var path, reversed_path;
      reversed_path = [];
      while (true) {
        reversed_path.push(node);
        node = node.previous;
        if (node === null) {
          break;
        }
      }
      path = [];
      while (reversed_path.length > 0) {
        path.push(reversed_path.pop());
      }
      return path;
    };

    AStarSearcher.prototype._clearNodeSearchData = function() {
      var i, len, n, ref;
      ref = this._node_set;
      for (i = 0, len = ref.length; i < len; i++) {
        n = ref[i];
        n.dist_to_start = 2e308;
        n.dist_to_goal = 2e308;
        n.previous = null;
      }
      this._node_set.clear();
    };

    return AStarSearcher;

  })();

}).call(this);

//# sourceMappingURL=a_star_searcher.js.map
