// Generated by CoffeeScript 1.11.1
(function() {
  BDS.Testing = (function() {
    function Testing() {
      this.test_heaps();
      this.test_DoubleLinkedList();
      this.test_points();
      this.test_lines();
      this.test_intersector();
      this.test_arrays();
      console.log("All tests have passed!");
      document.getElementById("text").innerHTML = "All Tests Have Passed!";
    }

    Testing.prototype.ASSERT = function(b) {
      var err;
      if (!b) {
        err = new Error();
        console.log(err.stack);
        debugger;
        throw new Error("Assertion Failed!");
      }
    };

    Testing.prototype.test_heaps = function() {
      var LE, h1, i, j, k, l, len, m, n, random_array, ref, ref1, ref2, sorted;
      LE = function(a, b) {
        return a <= b;
      };
      h1 = new BDS.Heap([], LE);
      this.ASSERT(h1.isEmpty());
      this.ASSERT(h1.size() === 0);
      h1.append([1, 3, 5, 7, 9, 0, 8, 4, 6, 2]);
      sorted = h1.toSortedArray();
      for (i = j = 0; j < 10; i = j += 1) {
        this.ASSERT(sorted[i] === i);
      }
      this.ASSERT(!h1.isEmpty());
      this.ASSERT(h1.size() === 10);
      for (i = k = 0; k < 10; i = k += 1) {
        this.ASSERT(h1.size() === 10 - i);
        this.ASSERT(h1.peek() === i);
        this.ASSERT(h1.dequeue() === i);
      }
      this.ASSERT(h1.isEmpty());
      random_array = [];
      len = 10000;
      for (i = l = 0, ref = len; l < ref; i = l += 1) {
        random_array.push(Math.random());
      }
      h1.clear();
      h1.append(random_array);
      sorted = h1.toSortedArray();
      for (i = m = 0, ref1 = len - 1; m < ref1; i = m += 1) {
        this.ASSERT(sorted[i] < sorted[i + 1]);
      }
      h1 = new BDS.Heap(random_array, LE);
      sorted = h1.toSortedArray();
      for (i = n = 0, ref2 = len - 1; n < ref2; i = n += 1) {
        this.ASSERT(sorted[i] < sorted[i + 1]);
      }
    };

    Testing.prototype.test_DoubleLinkedList = function() {
      var i, iter, j, k, l, list, results;
      list = new BDS.DoubleLinkedList();
      this.ASSERT(list.size() === 0);
      this.ASSERT(list.isEmpty());
      list.add(5);
      this.ASSERT(list.size() === 1);
      this.ASSERT(!list.isEmpty());
      list.append([0, 1, 2, 3, 4, 5, 6]);
      this.ASSERT(list.size() === 8);
      this.ASSERT(list.pop_front() === 5);
      for (i = j = 0; j < 7; i = ++j) {
        this.ASSERT(list.size() === 7 - i);
        this.ASSERT(list.pop_front() === i);
      }
      list.append([7, 6, 5, 4, 3, 2, 1, 0]);
      list.push(5);
      this.ASSERT(list.pop() === 5);
      list.push(7);
      this.ASSERT(list.pop() === 7);
      for (i = k = 0; k < 8; i = ++k) {
        this.ASSERT(list.size() === 8 - i);
        this.ASSERT(list.pop() === i);
      }
      this.ASSERT(list.isEmpty());
      list.append([7, 6, 5, 4, 3, 2, 1, 0]);
      this.ASSERT(list.size() === 8);
      list.clear();
      this.ASSERT(list.isEmpty());
      for (i = l = 0; l < 1000; i = ++l) {
        list.add(i);
      }
      iter = list.begin();
      i = 0;
      while (iter.hasNext()) {
        this.ASSERT(iter.next() === i);
        i++;
      }
      iter = list.end();
      while (iter.hasPrev()) {
        i--;
        this.ASSERT(iter.prev() === i);
      }
      iter = list.begin();
      i = 0;
      while (iter.hasNext()) {
        if (iter.next() % 2 === 1) {
          iter.remove();
        }
        i++;
      }
      iter = list.begin();
      i = 0;
      results = [];
      while (iter.hasNext()) {
        this.ASSERT(iter.next() === i);
        results.push(i += 2);
      }
      return results;
    };

    Testing.prototype.test_points = function() {
      var mag, p0, p1, p2;
      p0 = new BDS.Point(1, 1, 1);
      p1 = new BDS.Point(2, 3, 4);
      p2 = p0.add(p1);
      this.ASSERT(p2.x === 3);
      this.ASSERT(p2.y === 4);
      this.ASSERT(p2.z === 5);
      p2 = p0.sub(p1);
      this.ASSERT(p2.x === -1);
      this.ASSERT(p2.y === -2);
      this.ASSERT(p2.z === -3);
      p2 = p1.sub(p0);
      this.ASSERT(p2.x === 1);
      this.ASSERT(p2.y === 2);
      this.ASSERT(p2.z === 3);
      p2 = p0.multScalar(5);
      this.ASSERT(p2.x === 5);
      this.ASSERT(p2.y === 5);
      this.ASSERT(p2.z === 5);
      p2 = new BDS.Point(5, 0);
      mag = p2.norm2();
      this.ASSERT(24.99 < mag && mag < 25.01);
      mag = p2.norm();
      return this.ASSERT(4.99 < mag && mag < 5.01);
    };

    Testing.prototype.test_lines = function() {
      var l0, l1, points, pt;
      points = [new BDS.Point(0, 0), new BDS.Point(2, 0), new BDS.Point(1, 1), new BDS.Point(1, -1)];
      l0 = new BDS.Line(0, 1, points);
      l1 = new BDS.Line(2, 3, points);
      this.ASSERT(points[0] === l0.p1);
      this.ASSERT(points[1] === l0.p2);
      this.ASSERT(points[2] === l1.p1);
      this.ASSERT(points[3] === l1.p2);
      this.ASSERT(l0.line_side_test(points[2]) * l0.line_side_test(points[3]) < 0);
      this.ASSERT(l0.detect_intersection(l1));
      this.ASSERT(l1.detect_intersection(l0));
      this.ASSERT(points.length === 4);
      this.ASSERT(l0.intersect(l1));
      pt = l0.getLatestIntersectionPoint();
      this.ASSERT(pt.y < .0001 && pt.y > -.0001);
      this.ASSERT(points.length === 5);
    };

    Testing.prototype.test_intersector = function() {
      var i, i1, i2, intersector, j, k, l, len, lines, m, n, o, p, points, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, split_lines;
      len = 100;
      points = [new BDS.Point(0, 0), new BDS.Point(100, 0)];
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        points.push(new BDS.Point(i + .1, -1));
        points.push(new BDS.Point(i + .1, 1));
      }
      lines = [];
      lines.push(new BDS.Line(0, 1, points));
      for (i = k = 0, ref1 = len; k < ref1; i = k += 1) {
        i1 = 2 + i * 2;
        i2 = 2 + i * 2 + 1;
        lines.push(new BDS.Line(i1, i2, points));
      }
      intersector = new BDS.Intersector();

      /*
      Test Brute Force intersection.
       */
      intersector.intersect_brute_force(lines);
      split_lines = [];
      len = lines.length;
      for (i = l = 0, ref2 = len; l < ref2; i = l += 1) {
        lines[i].getSplitLines(split_lines);
      }
      this.ASSERT(split_lines.length === 101 + 100 + 100);
      for (i = m = 1, ref3 = len; m < ref3; i = m += 1) {
        this.ASSERT(Math.floor(split_lines[i].p1.x) === i - 1);
        this.ASSERT(Math.floor(split_lines[i].p2.x) === i);
      }
      for (i = n = 0, ref4 = len; 0 <= ref4 ? n < ref4 : n > ref4; i = 0 <= ref4 ? ++n : --n) {
        lines[i].clearIntersections();
      }

      /*
      Test Optimized Intersection.
       */
      len = 100;
      points = [new BDS.Point(0, 0), new BDS.Point(100, 0)];
      for (i = o = 0, ref5 = len; o < ref5; i = o += 1) {
        points.push(new BDS.Point(i + .1, -1));
        points.push(new BDS.Point(i + .1, 1));
      }
      lines = [];
      lines.push(new BDS.Line(0, 1, points));
      for (i = p = 0, ref6 = len; p < ref6; i = p += 1) {
        i1 = 2 + i * 2;
        i2 = 2 + i * 2 + 1;
        lines.push(new BDS.Line(i1, i2, points));
      }
      intersector.intersectLineSegments(lines);
      split_lines = [];
      len = lines.length;
      for (i = q = 0, ref7 = len; q < ref7; i = q += 1) {
        lines[i].getSplitLines(split_lines);
      }
      this.ASSERT(split_lines.length === 101 + 100 + 100);
      for (i = r = 1, ref8 = len; r < ref8; i = r += 1) {
        this.ASSERT(Math.floor(split_lines[i].p1.x) === i - 1);
        this.ASSERT(Math.floor(split_lines[i].p2.x) === i);
      }
    };

    Testing.prototype.test_halfedge = function() {};

    Testing.prototype.test_arrays = function() {
      var array, comparator, i, j;
      array = [0, 1, 2, 3, 4, 4, 4, 5];
      comparator = function(a, b) {
        return a <= b;
      };
      for (i = j = 0; j <= 3; i = ++j) {
        this.ASSERT(BDS.Arrays.binarySearch(array, i, comparator) === i);
      }
      this.ASSERT(BDS.Arrays.binarySearch(array, 4, comparator) === 6);
      this.ASSERT(BDS.Arrays.binarySearch(array, 89, comparator) === 7);
      return this.ASSERT(BDS.Arrays.binarySearch(array, -89, comparator) === -1);
    };

    return Testing;

  })();

  new BDS.Testing();


  /*
   * Tests for sorting algorithms.
  
  function is_sorted(array)
  {
      var len = array.length;
      
      var val = array[0];
      
      for(var i = 1; i < len; i++)
      {
          var next_val = array[i];
      
          if(next_val < val)
          {
              return false;
          }
          
          val = next_val;
      }
      
      return true;
  }
  
  function test_array()
  {
      return [1,3,2,5,4,7,7,9,13,0,2,1];
  }
  
  function test_sort(func, name)
  {
      var test = test_array();
      func(test);
      console.log(name + " " + is_sorted(test));
  }
  
  function test_sorting()
  {
  
      // -- Testing Code.
      var sort = new Sort();
      var test;
  
      test = test_array();
      console.log("UnSorted Array : " + test);
      console.log("isSorted = " + is_sorted(test));
      console.log("Insertion Sort.");
      sort.insertion_sort(test);
      console.log("Sorted Array : " + test);
      console.log("isSorted = " + is_sorted(test));
      console.log("");
  
      test = test_array();
      sort.quick_sort(test);
      console.log("Selection Sort = " + is_sorted(test));
  
      test = test_array();
      sort.insertion_sort(test);
      console.log("Insertion Sort = " + is_sorted(test));
  
      test = test_array();
      sort.quick_sort(test);
      console.log("Quick Sort = " + is_sorted(test));
  
      test = test_array();
      sort.merge_sort(test);
      console.log("Merge Sort = " + is_sorted(test));
  
      console.log(test);
  }
  
  function test_List()
  {
      var list = new List();
      
      for(i = 0; i < 10; i++)
      {   
          list.push(i);
      }
  
      console.log("Size = " + list.size);
      
      list.print();
      
      var iter = list.iterator();
      
      // Remove all even numbers.
      while(iter.hasNext())
      {       
          var elem = iter.next();
          if(elem % 2 == 0)
          {
              iter.remove();
          }
      
      }
      
      list.print();
      
      list.make_empty();
      for(i = 0; i < 10; i++)
      {   
          list.enq(i);
      }
      
      for(i = 0; i < 10; i++)
      {
          console.log(list.deq(i));
      }
      
      
  }
  
  //test_sorting();
  test_List();
   */

}).call(this);

//# sourceMappingURL=testing.js.map
