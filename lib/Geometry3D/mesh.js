// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BDS.Mesh = (function(superClass) {
    extend(Mesh, superClass);

    function Mesh(params) {
      var triangles;
      this._vertices = null;
      this._face_indices = null;
      this._triangles = null;
      this._bvh = null;
      this._faceLink = null;
      if (params.soup) {
        this._vertices = params.vertices;
        this._face_indices = params.face_indices;
      }
      if (params.bvh) {
        triangles = this._getInputTriangles(params);
        this._bvh = new BDS.BVH3D(triangles);
      }
      if (params.halfedge) {
        triangles = this._getInputTriangles(params);
        this._halfedgeMesh = new BDS.HalfedgeMesh(triangles);
      }
      if (params.faceLink) {
        this._faceLink = new BDS.FaceLinkGraph(params.face_indices);
      }
      if (params.triangle_list) {
        this._triangles = this._getInputTriangles(params);
      }
    }


    /*
    Public Interface
     */

    Mesh.prototype.getFaceLink = function() {
      return this._faceLink;
    };

    Mesh.prototype.getTriangles = function() {
      return this._triangles;
    };


    /*
    Private Helper Functions.
     */

    Mesh.prototype._getInputTriangles = function(params) {
      var faces, i, index_a, index_b, index_c, j, len, ref, tri, triangle, triangles, vertices;
      triangles = this._triangles;
      if (!triangles) {
        triangles = params.triangles;
      }
      if (!triangles && params.abc_triangles && params.face_indices) {
        triangles = [];
        len = params.abc_triangles.length;
        for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          tri = params.abc_triangles[i];
          triangle = BDS.Triangle.from_abc_triangle(tri);
          index_a = params.face_indices[3 * i + 0];
          index_b = params.face_indices[3 * i + 1];
          index_c = params.face_indices[3 * i + 2];
          triangle.setIndices(index_a, index_b, index_c);
          triangles.push(triangle);
        }
      }
      if (!triangles) {
        vertices = params.vertices;
        faces = params.face_indices;
        triangles = BDS.Mesh.construct_triangles(params.vertices, params.face_indices);
      }
      this._triangles = triangles;
      return triangles;
    };

    Mesh.construct_triangles = function(vertices, face_indices) {
      var i, i1, i2, i3, j, output, ref, triangle, v1, v2, v3;
      output = [];
      for (i = j = 0, ref = face_indices.length; j < ref; i = j += 3) {
        i1 = face_indices[i];
        i2 = face_indices[i + 1];
        i3 = face_indices[i + 2];
        v1 = vertices[i1];
        v2 = vertices[i2];
        v3 = vertices[i3];
        triangle = new BDS.Triangle(v1, v2, v3);
        triangle.setIndices(i1, i2, i3);
        output.push(triangle);
      }
      return output;
    };

    Mesh.prototype.ensure_bvh = function() {
      if (this._bvh) {
        return true;
      }
      if (this._triangles) {
        this._bvh = new BDS.BVH3D(triangles);
        return true;
      }
      console.error("BDS.Mesh: Queries not supported without BVH generation. No triangles found to fix the problem.");
      return false;
    };

    Mesh.prototype.rayQueryMin = function(rayQuery) {
      this.ensure_bvh();
      return this._bvh.rayQueryMin(rayQuery);
    };

    Mesh.prototype.rayQueryAll = function(rayQuery) {
      this.ensure_bvh();
      return this._bvh.rayQueryAll(rayQuery);
    };

    Mesh.prototype.rayQueryTime = function(rayQuery) {
      var local_query;
      this.ensure_bvh();
      local_query = rayQuery.initialize(rayQuery.ray);
      if (this._bvh.rayQueryMin(local_query)) {
        rayQuery.time = local_query.min_time;
        return true;
      }
      return false;
    };

    Mesh.prototype.rayQueryTimes = function(rayQuery) {
      var j, len1, local_query, ref, time;
      this.ensure_bvh();
      local_query = rayQuery.initialize(rayQuery.ray);
      if (this._bvh.rayQueryAll(local_query)) {
        ref = local.query_times;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          time = ref[j];
          rayQuery.times.push(time);
        }
        return true;
      }
      return false;
    };

    return Mesh;

  })(BDS.RayQueryable);

}).call(this);
