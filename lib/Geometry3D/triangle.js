// Generated by CoffeeScript 1.11.1

/*

BDS.Triangle class.

Written by Bryce Summers on July.23.2017.

Purpose: This class represents a single triangle in 3D space
         along with associated metrics and data.

Geometric Specification:
    3 points: .a, .b, and .c:  BDS.Point

Derived Geometric Values:
    Normal direction: .normal: BDS.Point (direction vector)
    center_point:     .center:   BDS.Point (Center point defined for this triangle)
    axis aligned bounding box: .aabb: BDS.Box

Topology:
    faceLink: BDS.FaceLinkData, We bidirectionally link to the faceLinkData objects, so as to keep the faceLink objects pure connectivity objects.
 */

(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BDS.Triangle = (function(superClass) {
    extend(Triangle, superClass);

    function Triangle(a, b, c) {
      this.a = a.clone();
      this.b = b.clone();
      this.c = c.clone();
      this.a_index = void 0;
      this.b_index = void 0;
      this.c_index = void 0;
    }

    Triangle.from_abc_triangle = function(tri) {
      return new BDS.Triangle(tri.a, tri.b, tri.c);
    };

    Triangle.prototype.setAssociatedData = function(obj) {
      this._obj = obj;
    };

    Triangle.prototype.getAssociatedData = function() {
      return this._obj;
    };

    Triangle.prototype.setIndices = function(i1, i2, i3) {
      this.a_index = i1;
      this.b_index = i2;
      return this.c_index = i3;
    };

    Triangle.prototype.normal = function() {
      var ab, ac;
      if (this._normal) {
        return this._normal;
      }
      ac = this.c.clone().sub(this.a);
      ab = this.b.clone().sub(this.a);
      this._normal = ac.cross(ab);
      return this._normal;
    };

    Triangle.prototype.computeCentroid = function() {
      return this.a.clone().add(this.b).add(this.c).divideScalar(3);
    };

    Triangle.prototype.ensureBoundingBox = function() {
      if (this.aabb === null) {
        this.generateBoundingBox();
      }
      return this._aabb;
    };

    Triangle.prototype.generateBoundingBox = function() {
      this._aabb = new BDS.Box();
      this._aabb.expandByPoint(this.a);
      this._aabb.expandByPoint(this.b);
      this._aabb.expandByPoint(this.c);
      return this._aabb;
    };

    Triangle.prototype.getBoundingBox = function() {
      return this._aabb;
    };

    Triangle.prototype.rayQueryMin = function(rayQuery) {
      var new_time, ray, result;
      ray = rayQuery.ray;
      result = this._isect_ray(ray);
      if (result === null) {
        return false;
      }
      new_time = result.time;
      if (new_time < rayQuery.min_time) {
        rayQuery.min_time = new_time;
        rayQuery.time = new_time;
        rayQuery.obj = this;
        return true;
      }
      return false;
    };

    Triangle.prototype.rayQueryAll = function(rayQuery) {
      var ray, result;
      ray = rayQuery.ray;
      result = this._isect_ray(ray);
      if (result === null) {
        return false;
      }
      rayQuery.times.push(result.time);
      rayQuery.objs.push(this);
      return true;
    };

    Triangle.prototype.rayQueryTime = function(rayQuery) {
      var ray, result;
      ray = rayQuery.ray;
      result = this._isect_ray(ray);
      if (result === null) {
        return false;
      }
      rayQuery.time = result.time;
      return true;
    };

    Triangle.prototype.rayQueryTimes = function(rayQuery) {
      var ray, result;
      ray = rayQuery.ray;
      result = this._isect_ray(ray);
      if (result === null) {
        return false;
      }
      rayQuery.times.push(result.time);
      return true;
    };

    Triangle.prototype._isect_ray = function(ray) {
      var det, dir, e1, e2, inv_det, origin, pvec, qvec, time, tvec, u, v, v0, v1, v2;
      origin = ray.getPoint();
      dir = ray.getDirection();
      v0 = this.a;
      v1 = this.b;
      v2 = this.c;
      e1 = v1.sub(v0);
      e2 = v2.sub(v0);
      pvec = dir.cross(e2);
      det = e1.dot(pvec);
      if (det < 1e-8 && det > -1e-8) {
        return null;
      }
      inv_det = 1 / det;
      tvec = origin.sub(v0);
      u = tvec.dot(pvec) * inv_det;
      if (u < 0 || u > 1) {
        return null;
      }
      qvec = tvec.cross(e1);
      v = dir.dot(qvec) * inv_det;
      if (v < 0 || u + v > 1) {
        return null;
      }
      time = e2.dot(qvec) * inv_det;
      return {
        time: time,
        u: u,
        v: v
      };
    };

    return Triangle;

  })(BDS.RayQueryable);

}).call(this);
