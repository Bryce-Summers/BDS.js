// Generated by CoffeeScript 1.11.1

/*

Ray Queryable Abstract parent class
for geometric objects that support ray casting.

Written by Bryce Summers on July. 25th. 2017


This class handles a lot of the different return logics.

Child classes at minnimum need to implement the following functions:
    @_isect_ray(ray) --> returns the time of intersection. < 0 if not found.
    @_exit_ray(ray, enter_time) --> returns {needed:, ray:, time:,}
     - needed is true if the geometry has a volume and finding an exit location makes sense.
       needed is false if this geometry is just a flat primitive, like a triangle, quad, plane, etc.
     - ray contains the exit ray if needed was true.
     - time contains the time along the input ray that the exit ray starts at,
       the exit ray then proceeds in the opposite direction of the input ray.
 */

(function() {
  BDS.RayQueryable = (function() {
    function RayQueryable() {}


    /*
    Ray Queries
     Here are some top of the brain approaches:
     - Raycast all 6 quad faces.
     - Raycast 12 triangle faces.
     - Since we are axis aligned, we could the ray reletive to center of box space, 
       then prune faces that the ray won't hit. This seems to be the major win for Axis-Alignment.
    
     I looked online and found a better quadrant based approach and modified it to find the exit point for the box as well.
     */

    RayQueryable.prototype.rayQueryMin = function(rayQuery) {
      var new_time;
      new_time = this._isect_ray(rayQuery.ray);
      if (0 <= new_time && new_time < rayQuery.min_time) {
        rayQuery.time = new_time;
        rayQuery.min_time = new_time;
        rayQuery.obj = this;
        return true;
      }
      return false;
    };

    RayQueryable.prototype.rayQueryAll = function(rayQuery) {
      if (this.rayQueryTimes(rayQuery)) {
        rayQuery.objs.push(this);
        return true;
      }
      return false;
    };

    RayQueryable.prototype.rayQueryTime = function(rayQuery) {
      var new_time;
      new_time = this._isect_ray(rayQuery.ray);
      if (0 <= new_time) {
        rayQuery.time = new_time;
        return true;
      }
      return false;
    };

    RayQueryable.prototype.rayQueryTimes = function(rayQuery) {
      var enter_time, exit_ray, exit_search, exit_time;
      enter_time = this._isect_ray(rayQuery.ray);
      if (enter_time < 0) {
        return false;
      }
      rayQuery.times.push(enter_time);
      exit_search = this._exit_ray(rayQuery.ray, new_time);
      if (!exit_search.needed) {
        return true;
      }
      exit_ray = exit_search.ray;
      exit_time = exit_search.origin_time - this._isect_ray(exit_ray);
      rayQuery.times.push(exit_time);
      return true;
    };

    return RayQueryable;

  })();

}).call(this);
