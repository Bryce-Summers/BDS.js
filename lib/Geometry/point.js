// Generated by CoffeeScript 1.11.1

/*
Point.

Written by Bryce Summers on 1 - 2 - 2017.

Implements Arithmetic.

add, sub, multScalar
 */

(function() {
  BDS.newDirection = function(x, y, z) {
    return new BDS.Point(x, y, z);
  };

  BDS.Point = (function() {
    function Point(x1, y1, z1) {
      this.x = x1;
      this.y = y1;
      this.z = z1;
      if (this.x === void 0 || isNaN(this.x)) {
        debugger;
      }
      if (this.y === void 0 || isNaN(this.y)) {
        debugger;
      }
      if (!this.z) {
        this.z = 0.0;
      }
    }

    Point.prototype.clone = function() {
      return new BDS.Point(this.x, this.y, this.z);
    };

    Point.newFrom = function(pt) {
      var out;
      out = new BDS.Point(pt.x, pt.y, pt.z);
      return out;
    };

    Point.prototype.copyFrom = function(pt) {
      this.x = pt.x;
      this.y = pt.y;
      return this.z = pt.z;
    };

    Point.prototype.add = function(pt) {
      var out;
      out = this.clone();
      out.x += pt.x;
      out.y += pt.y;
      out.z += pt.z;
      return out;
    };

    Point.prototype.sub = function(pt) {
      var out;
      out = this.clone();
      out.x -= pt.x;
      out.y -= pt.y;
      out.z -= pt.z;
      return out;
    };

    Point.prototype.multScalar = function(s) {
      var out;
      out = this.clone();
      out.x *= s;
      out.y *= s;
      out.z *= s;
      return out;
    };

    Point.prototype.divScalar = function(s) {
      var out;
      out = this.clone();
      out.x /= s;
      out.y /= s;
      out.z /= s;
      return out;
    };

    Point.prototype.toArray = function() {
      return [this.x, this.y, this.z];
    };

    Point.prototype.toString = function() {
      var output;
      output = "Point(" + this.x + ", " + this.y;
      if (this.z) {
        output += ", " + this.z;
      }
      output += ")";
      return output;
    };

    Point.prototype.distanceTo = function(pt) {
      return pt.sub(this).norm();
    };

    Point.prototype.directionTo = function(pt) {
      return pt.sub(this).normalize();
    };

    Point.directionFromAngle = function(angle) {
      return new BDS.Point(Math.cos(angle), Math.sin(angle), 0);
    };

    Point.prototype.angle = function() {
      return Math.atan2(this.y, this.x);
    };

    Point.prototype.angleTo = function(pt) {
      return pt.sub(this).angle();
    };

    Point.prototype.angleBetween = function(pt) {
      var cosA, dot;
      dot = this.dot(pt);
      cosA = dot / (this.norm() * pt.norm());
      return Math.acos(cosA);
    };

    Point.prototype.magnitude = function() {
      return this.norm();
    };

    Point.prototype.norm = function() {
      return Math.sqrt(this.norm2());
    };

    Point.prototype.norm2 = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };

    Point.prototype.min = function(pt) {
      var out;
      out = this.clone();
      out.x = Math.min(this.x, pt.x);
      out.y = Math.min(this.y, pt.y);
      out.z = Math.min(this.z, pt.z);
      return out;
    };

    Point.prototype.max = function(pt) {
      var out;
      out = this.clone();
      out.x = Math.max(this.x, pt.x);
      out.y = Math.max(this.y, pt.y);
      out.z = Math.max(this.z, pt.z);
      return out;
    };

    Point.prototype.normalize = function() {
      return this.divScalar(this.norm());
    };

    Point.prototype.dot = function(pt) {
      return pt.x * this.x + pt.y * this.y + pt.z * this.z;
    };

    Point.prototype.cross = function(o) {
      return new BDS.Point(this.y * o.z - this.z * o.y, this.z * o.x - this.x * o.z, this.x * o.y - this.y * o.x);
    };

    Point.prototype.lessThan = function(pt) {
      return this.x < pt.x && this.y < pt.y && this.z < pt.z;
    };

    Point.prototype.lessThanOrEqual = function(pt) {
      return this.x <= pt.x && this.y <= pt.y && this.z <= pt.z;
    };

    Point.prototype.greaterThan = function(pt) {
      return this.x > pt.x && this.y > pt.y && this.z > pt.z;
    };

    Point.prototype.greaterThanOrEqual = function(pt) {
      return this.x >= pt.x && this.y >= pt.y && this.z >= pt.z;
    };

    return Point;

  })();

}).call(this);
