// Generated by CoffeeScript 1.11.1

/*
Polyline class (also represents polygons)

Written by Bryce Summers on 1 - 4 - 2017.

Note: Closed Polylines are polygons...
 - So we will put all of our polygon code into this class.
 */

(function() {
  BDS.Polyline = (function() {
    function Polyline(_isClosed, points_in) {
      this._isClosed = _isClosed;
      if (this._isClosed === void 0) {
        this._isClosed = false;
      }
      this._points = [];
      if (points_in) {
        this.appendPoints(points_in);
      }

      /*
       * These are commented out to save memory for applications that don't need these.
      @_boundingbox = null
      @_lineBVH = null
      @_obj # Associated Obj.
       */
    }

    Polyline.prototype.appendPoints = function(array) {
      var j, len1, p;
      for (j = 0, len1 = array.length; j < len1; j++) {
        p = array[j];
        this.addPoint(p);
      }
    };

    Polyline.prototype.addPoint = function(p) {
      this._points.push(p);
    };

    Polyline.prototype.removeLastPoint = function() {
      return this._points.pop();
    };

    Polyline.prototype.getPoint = function(index) {
      return this._points[index];
    };

    Polyline.prototype.size = function() {
      return this._points.length;
    };

    Polyline.prototype.isClosed = function() {
      return this._isClosed;
    };


    /*
    * http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/
    * Computes the area of a 2D polygon directly from the polygon's coordinates.
    * The area will be positive or negative depending on the
    * clockwise / counter clockwise orientation of the points.
    * Also see: https://brycesummers.wordpress.com/2015/08/24/a-proof-of-simple-polygonal-area-via-greens-theorem/
    * Note: This function interprets this polyline as closed.
     *  -> float
     */

    Polyline.prototype.computeArea = function() {
      var area, i, j, len, p1, p2, ref;
      len = this._points.length;
      p1 = this._points[len - 1];
      area = 0.0;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        p2 = this._points[i];
        area += (p2.x + p1.x) * (p2.y - p1.y);
        p1 = p2;
      }
      return area / 2.0;
    };

    Polyline.prototype.isComplemented = function() {
      return this.computeArea() > 0;
    };

    Polyline.prototype.generateBoundingBox = function(polygon) {
      var i, j, len, pt, ref;
      this._boundingbox = new BDS.Box();
      len = polygon.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        pt = polygon.getPoint(i);
        this._boundingbox.expandByPoint(pt);
      }
      return this._boundingbox;
    };

    Polyline.prototype.getBoundingBox = function() {
      return this._boundingbox;
    };

    Polyline.prototype.generateBVH = function() {
      var segments;
      segments = this.toPolylineSegments();
      return this._lineBVH = new BDS.BVH2(segments);
    };

    Polyline.prototype.setAssociatedData = function(obj) {
      return this._obj = obj;
    };

    Polyline.prototype.getAssociatedData = function() {
      return this._obj;
    };


    /*
    getBVH: () ->
        return @_lineBVH()
     */

    Polyline.prototype.toPolylineSegments = function() {
      var i, j, len, output, p0, p1, ref;
      output = [];
      len = this._points.length;
      for (i = j = 0, ref = len - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p0 = this._points[i];
        p1 = this._points[i + 1];
        output.push(new BDS.Polyline(false, [p0, p1]));
      }
      if (this._isClosed) {
        p0 = this._points[len - 1];
        p1 = this._points[0];
        output.push(new BDS.Polyline(false, [p0, p1]));
      }
      return output;
    };

    Polyline.prototype._toLineSegments = function() {
      var i, j, len, output, ref;
      output = [];
      len = this._points.length;
      for (i = j = 0, ref = len - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        output.push(new BDS.Line(i, i + 1, this._points));
      }
      if (this._isClosed) {
        output.push(new BDS.Line(len - 1, 0, this._points));
      }
      return output;
    };

    Polyline.prototype.containsPoint = function(pt) {
      if (this._lineBVH) {
        throw new ERROR("Implement me Please!");
      } else {
        return this._point_in_polygon_test(pt);
      }
    };

    Polyline.prototype._point_in_polygon_test = function(pt) {
      var j, len1, odd, ray, segment, segments;
      ray = new BDS.Ray(pt, BDS.newDirection(1.0, 0));
      odd = false;
      segments = this._toLineSegments();
      for (j = 0, len1 = segments.length; j < len1; j++) {
        segment = segments[j];
        if (ray.detect_intersection_with_line(segment)) {
          odd = !odd;
        }
      }
      return odd;
    };

    return Polyline;

  })();

}).call(this);
