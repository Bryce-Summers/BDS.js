// Generated by CoffeeScript 1.11.1

/*
Heap
Implements a priority Queue using an Array Heap.
Written by Bryce Summers on 11 - 2 - 2017.

 * 
 * Note : This is a MIN heap.
 * 
 * Heap property :  For every element in the tree,
 *                  it is less than or equal to its left and right children in the tree as defined by the elements at the indexes associated by
 *                  the relationships index_left(index) and index_right(index).
 *  
 * Root node is always at index 0.
 * 
 * Left biased, when equal keys are present, the one on the left will be chosen.
 * 
 * Allows for duplicate keys.
 * 
 * Binary tree invariants :
 * The heap is represented by a binary tree that is encoded by index relationships within an unbounded array.
 * We maintain the UBA with a minimality of nodes, so the UBA will only contain N elements, when size = n.
 * 
 * The heap is as balanced as possible. This causes their to be a preference for left children over right children.
 * 
 * FIXME : I will need to work to preserve key stability, so that all keys will eventually be deleted, even if all keys entered are equal.
 */

(function() {
  BDS.Heap = (function() {
    Heap._D = 3;

    function Heap(data_in, comparator) {
      this._LE = comparator;
      if (!data_in) {
        this._data = [];
      } else {
        this._data = data_in.slice(0);
        this._heapify();
      }
    }

    Heap.prototype.size = function() {
      return this._data.length;
    };

    Heap.prototype.isEmpty = function() {
      return this._data.length === 0;
    };

    Heap.prototype.add = function(elem) {
      var len;
      len = this._data.length;
      this._data.push(elem);
      return this._sift_up(len);
    };

    Heap.prototype.append = function(elems) {
      var e, j, len1, results;
      results = [];
      for (j = 0, len1 = elems.length; j < len1; j++) {
        e = elems[j];
        results.push(this.add(e));
      }
      return results;
    };

    Heap.prototype.peek = function() {
      return this._data[0];
    };

    Heap.prototype.dequeue = function() {
      var last, output;
      if (this._data.length === 1) {
        return this._data.pop();
      }
      output = this._data[0];
      last = this._data.pop();
      this._data[0] = last;
      this.sift_down(0);
      return output;
    };

    Heap.prototype.toArray = function() {
      return this._data.slice(0);
    };

    Heap.prototype.getElem = function(index) {
      return this._data[index];
    };


    /*
    // Heapifies all of the nodes of the Tree with a root at the given index.
    // Builds the heap invariant downwards to all sub trees.
    // O(n), checks each node in the tree once.
    // Transforms a random array into an array that meets the heap invariants.
     */

    Heap.prototype._heapify = function() {
      var i, j, ref;
      for (i = j = ref = this._data.length - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
        this.sift_down(i);
      }
    };


    /*
    // Given an index, swaps the node down the tree while maintaining the min
    // heap invariant until the node is in an invariant correct place.
    // O(log(n)). Non recursive, so has O(1) function calls.
    // SIFT down.
     */

    Heap.prototype.sift_down = function(index) {
      var child, child_index, elem, i, min_elem, min_elem_index, size;
      size = this._data.length;
      child_index = this._index_child(index, 1);
      elem = this._data[index];
      while (child_index < size) {
        min_elem_index = -1;
        min_elem = elem;
        i = child_index;
        while (i < child_index + BDS.Heap._D && i < size) {
          child = this._data[i];
          if (this._LE(child, min_elem)) {
            min_elem = child;
            min_elem_index = i;
          }
          i++;
        }
        if (min_elem === elem) {
          return;
        }
        this._min_first(index, min_elem_index);
        index = min_elem_index;
        child_index = this._index_child(index, 1);
      }
    };

    Heap.prototype._sift_up = function(index) {
      var parent_index, results;
      parent_index = this._index_parent(index);
      results = [];
      while (index > 0 && this._min_first(parent_index, index)) {
        index = parent_index;
        results.push(parent_index = this._index_parent(index));
      }
      return results;
    };

    Heap.prototype._index_parent = function(index) {
      return Math.floor((index - 1) / BDS.Heap._D);
    };

    Heap.prototype._index_child = function(index, child_index) {
      return BDS.Heap._D * index + child_index;
    };

    Heap.prototype._min_first = function(index1, index2) {
      var elem1, elem2;
      elem1 = this._data[index1];
      elem2 = this._data[index2];
      if (!this._LE(elem1, elem2)) {
        BDS.Arrays.swap(this._data, index1, index2);
        return true;
      }
      return false;
    };

    Heap.prototype.toString = function() {
      var elem, j, len1, output, ref;
      output = "";
      output += "\nMinHeap[";
      ref = this._data;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        elem = ref[j];
        output += elem;
        output += ",\n";
      }
      output += "]";
      return output;
    };

    Heap.prototype.clone = function() {
      return new BDS.Heap(this._data, this._LE);
    };

    Heap.prototype.toSortedArray = function() {
      var heap, i, j, len, output, ref;
      len = this._data.length;
      output = [];
      heap = this.clone();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        output.push(heap.dequeue());
      }
      return output;
    };

    Heap.prototype.clear = function() {
      return this._data = [];
    };

    return Heap;

  })();

}).call(this);
