// Generated by CoffeeScript 1.11.1
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  BDS.BVH3D = (function(superClass) {
    extend(BVH3D, superClass);

    BVH3D.MAX_OBJECTS_PER_LEAF = 4;

    function BVH3D(triangles, xyz) {
      var i, j, left_partition, ref, ref1, right_partition;
      if (!triangles) {
        triangles = [];
      }
      if (!xyz) {
        xyz = {
          val: 'x'
        };
      }
      this._leafs = [];
      this._leaf_node = false;
      this._size = triangles.length;
      this._ensure_bounding_boxes(triangles);
      this._AABB = this._compute_AABB(triangles);
      if (triangles.length < BDS.BVH3D.MAX_OBJECTS_PER_LEAF) {
        this._leaf_node = true;
        this._leafs = [];
        for (i = j = 0, ref = triangles.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(triangles[i]);
        }
        return;
      }
      triangles = this._sort_triangle_list(triangles, xyz);
      ref1 = this._partition_by_SA(triangles), left_partition = ref1[0], right_partition = ref1[1];
      xyz.val = this._nextXYZ(xyz);
      this._left = new BDS.BVH3D(left_partition, xyz);
      this._right = new BDS.BVH3D(right_partition, xyz);
    }

    BVH3D.prototype.toBoundingBox = function() {
      return this._AABB.clone();
    };

    BVH3D.prototype._copy_from = function(bvh) {
      this._leaf_node = bvh._leaf_node;
      this._size = bvh._size;
      this._AABB = bvh._AABB;
      this._leafs = bvh._leafs;
      this._left = bvh._left;
      return this._right = bvh._right;
    };


    /*
     - Private Construction Methods. -----------------------
     */

    BVH3D.prototype._sort_triangle_list = function(triangle_list, xyz) {
      var centroid_index_list, i, j, len, output, ref, sort_function, triangle_index;
      centroid_index_list = this._centroid_index_list(triangle_list);
      sort_function = function(a, b) {
        switch (xyz.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
          case 'z':
            return a.centroid.z - b.centroid.z;
        }
        debugger;
        return console.log("xyz is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle_index = centroid_index_list[i].index;
        output.push(triangle_list[triangle_index]);
      }
      return output;
    };

    BVH3D.prototype._nextXYZ = function(xyz) {
      switch (xyz.val) {
        case 'x':
          return 'y';
        case 'y':
          return 'z';
        case 'z':
          return 'x';
      }
      debugger;
      console.log("xyz is malformed.");
      debugger;
      return console.log("Case not handled.");
    };

    BVH3D.prototype._centroid_index_list = function(triangle_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = triangle_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(triangle_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    BVH3D.prototype._computeCentroid = function(triangle) {
      return triangle.computeCentroid();
    };

    BVH3D.prototype._partition_by_SA = function(triangle_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [triangle_list[0]];
      right = [];
      i0 = triangle_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(triangle_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(triangle_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(triangle_list[i]);
      }
      return [left, right];
    };

    BVH3D.prototype._ensure_bounding_boxes = function(triangle_list) {
      var j, len1, results, triangle;
      results = [];
      for (j = 0, len1 = triangle_list.length; j < len1; j++) {
        triangle = triangle_list[j];
        results.push(triangle.generateBoundingBox());
      }
      return results;
    };

    BVH3D.prototype._compute_AABB = function(triangle_list) {
      var AABB, i, j, output, ref, triangle;
      output = new BDS.Box();
      for (i = j = 0, ref = triangle_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        triangle = triangle_list[i];
        AABB = triangle.getBoundingBox();
        output = output.union(AABB);
      }
      return output;
    };

    BVH3D.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };


    /*
    
    Modification functions.
     - add and remove triangles,
     - optimize: rebalance the bvh tree to ensure quick query times.
    
    Future:
     - union, merge two bvh trees, this may deffer or speed up construction time.
     - intersection
     - difference
     */

    BVH3D.prototype.optimize = function() {};

    BVH3D.prototype.add = function(polyline) {
      var potential_bb_left, potential_bb_right, sa_diff_left, sa_diff_right;
      polyline.ensureBoundingBox();
      if (this._leaf_node) {
        this._leafs.push(polyline);
        this._AABB = this._AABB.union(polyline.getBoundingBox());
        this._size++;
        return;
      }
      potential_bb_left = this._left._AABB.union(polyline.getBoundingBox());
      potential_bb_right = this._right._AABB.union(polyline.getBoundingBox());
      sa_diff_left = this._compute_SA(potential_bb_left) - this._compute_SA(this._left._AABB);
      sa_diff_right = this._compute_SA(potential_bb_right) - this._compute_SA(this._right._AABB);
      if (sa_diff_left < sa_diff_right) {
        this._left.add(polyline);
      } else {
        this._right.add(polyline);
      }
      this._AABB = this._left._AABB.union(this._right._AABB);
      this._size++;
    };

    BVH3D.prototype.remove = function(polyline) {
      var j, len1, old_line, old_lines, polyline_bb, removed;
      polyline.ensureBoundingBox();
      polyline_bb = polyline.getBoundingBox();
      if (!polyline_bb.intersects_box(this._AABB)) {
        return false;
      }
      if (this._leaf_node) {
        this._AABB = new BDS.Box();
        old_lines = this._leafs;
        this._leafs = [];
        removed = false;
        for (j = 0, len1 = old_lines.length; j < len1; j++) {
          old_line = old_lines[j];
          if (polyline === old_line) {
            removed = true;
            this._size--;
            continue;
          }
          this._AABB = this._AABB.union(old_line.getBoundingBox());
          this._leafs.push(old_line);
        }
        return removed;
      }
      removed = this._left.remove(polyline);
      if (!removed) {
        removed = this._right.remove(polyline);
      }
      if (!removed) {
        return false;
      }
      this._size--;
      if (this._size === 0) {
        this._leaf_node = true;
        this._leafs = [];
        this._left = void 0;
        this._right = void 0;
        return removed;
      }
      if (this._left._size === 0) {
        this._copy_from(this._right);
        return true;
      }
      if (this._right._size === 0) {
        this._copy_from(this._left);
        return true;
      }
      this._AABB = this._left._AABB.union(this._right._AABB);
      return true;
    };


    /*
    
    Geometric Queries,
        the point of the BVH3D data structure is to make these queries as fast as possible.
        all queries return one of the BVH's triangles, representing collision geometry, which may then have associated data.
    
     -- Ray queries, ray's can start anywhere, even inside of a box and head off in any direction.
    
     - rayQueryMin(rQ), rQ will contain the first triangle that this ray intersects,
       returns true iff a triangle was found.
     - rayQueryAll(rQ), rQ will contain all of the triangles that this ray intersects.
       returns true iff a triangle was found.
    
    Future: These function can be used without disrubing the rQ's isect object values.
        and when simple queries such as determining the number of isects for pt in/out is all that is needed.
     - rayQueryTime(rq), rQ will contain .time with the nearest intersection time
       returns true iff an intersection was found.
     - rayQueryTimes(rQ), rQ will contain .times[] with all of the intersection times.
       return true iff at least 1 intersection was found.
    
    Future
     - query_box_all, returns all triangles with bounding boxes intersecting a given box.
     */

    BVH3D.prototype.rayQueryMin = function(rayQuery) {
      var enter_far, enter_left, enter_near, enter_right, far_node, found, found_near, j, left_AABB, len1, min_time, near_node, ref, right_AABB, triangle;
      if (this._leaf_node) {
        found = false;
        ref = this._leafs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          triangle = ref[j];
          if (triangle.rayQueryMin(rayQuery)) {
            found = true;
          }
        }
        return found;
      }
      left_AABB = this._left._AABB;
      right_AABB = this._right._AABB;
      min_time = rayQuery.min_time;
      enter_left = Number.MAX_VALUE;
      enter_right = Number.MAX_VALUE;
      if (left_AABB.rayQueryTime(rayQuery)) {
        enter_left = rayQuery.time;
      }
      if (right_AABB.rayQueryTime(rayQuery)) {
        enter_right = rayQuery.time;
      }
      if (min_time < enter_left && min_time < enter_right) {
        return false;
      }
      if (enter_left < min_time && min_time < enter_right) {
        return this._left.rayQueryMin(rayQuery);
      }
      if (enter_right < min_time && min_time < enter_left) {
        return this._right.rayQueryMin(rayQuery);
      }
      if (enter_left < enter_right) {
        near_node = this._left;
        far_node = this._right;
        enter_near = enter_left;
        enter_far = enter_right;
      } else {
        near_node = this._right;
        far_node = this._left;
        enter_near = enter_right;
        enter_far = enter_left;
      }
      found_near = false;
      if (near_node.rayQueryMin(rayQuery)) {
        found_near = true;
        if (rayQuery.min_time < enter_far) {
          return true;
        }
      }
      if (far_node.rayQueryMin(rayQuery)) {
        return true;
      }
      return found_near;
    };

    BVH3D.prototype.rayQueryAll = function(rayQuery) {
      var found, j, len1, ref, triangle;
      if (this._leaf_node) {
        found = false;
        ref = this._leafs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          triangle = ref[j];
          if (triangle.rayQueryAll(rayQuery)) {
            found = true;
          }
        }
        return found;
      }
      if (this._AABB.rayQueryTimes(rayQuery).length) {
        return false;
      }
      found = false;
      if (this._left.rayQueryAll(rayQuery)) {
        found = true;
      }
      if (this._right.rayQueryAll(rayQuery)) {
        found = true;
      }
      return found;
    };

    BVH3D.prototype.query_box_all = function(query_box, output_list) {
      return console.log("BDS.BVH3D: query_box_all, not yet implemented.");
    };

    return BVH3D;

  })(BDS.RayQueryable);

}).call(this);
