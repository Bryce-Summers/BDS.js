// Generated by CoffeeScript 1.11.1
(function() {
  BDS.BVH2D = (function() {
    function BVH2D(polygons, xy) {
      var i, j, left_partition, ref, ref1, right_partition;
      if (!xy) {
        xy = {
          val: 'x'
        };
      }
      this._leafs = [];
      this._leaf_node = false;
      this._ensure_bounding_boxes(polygons);
      this._AABB = this._compute_AABB(polygons);
      if (polygons.length < 4) {
        this._leaf_node = true;
        for (i = j = 0, ref = polygons.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(polygons[i]);
        }
        return;
      }
      if (xy.dim === 2) {
        this._AABB.min.z = -1;
        this._AABB.max.z = +1;
      }
      polygons = this._sort_polygon_list(polygons, xy);
      ref1 = this._partition_by_SA(polygons), left_partition = ref1[0], right_partition = ref1[1];
      xy.val = this._nextXY(xy);
      this._left = new BDS.BVH2D(left_partition, xy);
      this._right = new BDS.BVH2D(right_partition, xy);
    }


    /*
     - Private Construction Methods. -----------------------
     */

    BVH2D.prototype._sort_polygon_list = function(polygon_list, xy) {
      var centroid_index_list, i, j, len, output, polygon_index, ref, sort_function;
      centroid_index_list = this._centroid_index_list(polygon_list);
      sort_function = function(a, b) {
        switch (xy.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
        }
        debugger;
        return console.log("xy is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = polygon_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon_index = centroid_index_list[i].index;
        output.push(polygon_list[polygon_index]);
      }
      return output;
    };

    BVH2D.prototype._nextXY = function(xy) {
      switch (xy.val) {
        case 'x':
          return 'y';
        case 'y':
          return 'x';
      }
      debugger;
      console.log("xy is malformed.");
      debugger;
      return console.log("Case not handled.");
    };

    BVH2D.prototype._centroid_index_list = function(polygon_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = polygon_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(polygon_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    BVH2D.prototype._computeCentroid = function(polygon) {
      var centroid, i, j, len, point, ref;
      centroid = new BDS.Point(0, 0);
      len = polygon.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        point = polygon.getPoint(i);
        centroid = centroid.add(point);
      }
      return centroid.divScalar(len);
    };

    BVH2D.prototype._partition_by_SA = function(polygon_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [polygon_list[0]];
      right = [];
      i0 = polygon_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(polygon_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(polygon_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(polygon_list[i]);
      }
      return [left, right];
    };

    BVH2D.prototype._ensure_bounding_boxes = function(polygon_list) {
      var err, i, j, len, polygon, ref, results;
      len = polygon_list.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon = polygon_list[i];
        if (!polygon) {
          err = new Error();
          console.log(err.stack);
          debugger;
          throw new Error("BSD.BVH: Polygon is missing a bounding box.");
        }
        if (!polygon.boundingBox) {
          results.push(this._computeBoundingBox(polygon));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    BVH2D.prototype._computeBoundingBox = function(polygon) {
      var AABB, i, j, len, pt, ref;
      AABB = new BDS.Box();
      len = polygon.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        pt = polygon.getPoint(i);
        AABB.expandByPoint(pt);
      }
      return polygon.setBoundingBox(AABB);
    };

    BVH2D.prototype._compute_AABB = function(polygon_list) {
      var AABB, i, j, output, polygon, ref;
      output = new BDS.Box();
      for (i = j = 0, ref = polygon_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon = polygon_list[i];
        AABB = polygon.getBoundingBox();
        output = output.union(AABB);
      }
      return output;
    };

    BVH2D.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };

    BVH2D.prototype.query_point = function(x, y) {
      debugger;
      var ray;
      throw new Error("FIXME");
      ray = new THREE.Ray(new THREE.Vector3(x, y, 10), new THREE.Vector3(0, 0, 1));
      return this.query_ray(ray);
    };

    BVH2D.prototype.toPolylines = function() {
      var polylines;
      polylines = [];
      this._toPolylines(polylines);
      return polylines;
    };

    BVH2D.prototype._toPolylines = function(output) {
      var max, max_x, max_y, min, min_x, min_y, p0, p1, p2, p3, polyline;
      min = this._AABB.min;
      max = this._AABB.max;
      min_x = min.x;
      min_y = min.y;
      max_x = max.x;
      max_y = max.y;
      p0 = new BDS.Point(min_x, min_y, 0);
      p1 = new BDS.Point(max_x, min_y, 0);
      p2 = new BDS.Point(max_x, max_y, 0);
      p3 = new BDS.Point(min_x, max_y, 0);
      polyline = new BDS.Polyline(true, [p0, p1, p2, p3]);
      output.push(polyline);
      if (!this._leaf_node) {
        this._left._toPolylines(output);
        this._right._toPolylines(output);
      }
    };

    return BVH2D;

  })();

}).call(this);
