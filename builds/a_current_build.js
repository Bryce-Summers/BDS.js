/*! Bryce Data Structures, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 27-02-2017
 */
/*
 * Defines namespaces.
 * Adapted by Bryce Summers on 1 - 2 - 2017.
 */

// Bryce Data Structures.
BDS = {};
// Generated by CoffeeScript 1.11.1

/*
Standard Array methods.
 */

(function() {
  BDS.Arrays = {};

  BDS.Arrays.swap = function(array, i1, i2) {
    var temp;
    temp = array[i1];
    array[i1] = array[i2];
    array[i2] = temp;
  };

  BDS.Arrays.binarySearch = function(array, elem_target, comparator) {
    var elem_current, max, mid, min;
    min = 0;
    max = array.length - 1;
    mid = Math.floor(max / 2);
    while (min <= max) {
      elem_current = array[mid];
      if (comparator(elem_current, elem_target)) {
        min = mid + 1;
      } else {
        max = mid - 1;
      }
      mid = Math.floor((min + max) / 2);
    }
    return min - 1;
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Intersector

Written by Bryce Summers on 1 - 2 - 2017.

features: Efficient Line Segment Intersection.
 */

(function() {
  BDS.Intersector = (function() {
    function Intersector() {}


    /*
    Calls the Line.intersect method on all intersecting lines.
    Does not treat lines that intersect at common points as intersecting.
     * takes arrays of BDS.Line objects.
    BDS.Line[] -> () [intersection sideeffects]
     */

    Intersector.prototype.intersectLineSegments = function(lines) {
      var event, event_queue, i, j, len, line, ref, sweepSet;
      event_queue = new BDS.Intersector.EventPQ(lines);
      sweepSet = new BDS.Intersector.LineSweepSet();
      len = event_queue.size();
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        event = event_queue.delMin();
        switch (event.type) {
          case BDS.Intersector.Event.ENTER:
            line = event.line;
            sweepSet.intersect_with_line(line);
            sweepSet.add(event.twin);
            continue;
          case BDS.Intersector.Event.EXIT:
            sweepSet.remove(event);
            continue;
        }
      }
    };


    /*
    Returns true iff there is at least one valid intersection detected in the input set of polylines.
    Does not treat lines that intersect at common points as intersecting.
    
    non_intersection_indices demarcate ranges of indices that should not be intersected against each other.
    Assumes that the indices are in rted order.
     */

    Intersector.prototype.detect_intersection_line_segments_partitioned = function(lines, partition_indices) {
      var event, event_queue, i, j, len, line, ref, sweepSet;
      event_queue = new BDS.Intersector.EventPQ(lines);
      sweepSet = new BDS.Intersector.LineSweepSet();
      len = event_queue.size();
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        event = event_queue.delMin();
        switch (event.type) {
          case BDS.Intersector.Event.ENTER:
            line = event.line;
            if (sweepSet.detect_intersection_with_line_partitioned(line, partition_indices)) {
              return true;
            }
            sweepSet.add(event.twin);
            continue;
          case BDS.Intersector.Event.EXIT:
            sweepSet.remove(event);
            continue;
        }
      }
      return false;
    };


    /*
    Slower, but more robust version of intersect.
    Naive N^2 Intersection Algorithm.
     */

    Intersector.prototype.intersect_brute_force = function(lines) {
      var a, b, j, k, numLines, ref, ref1, ref2;
      numLines = lines.length;
      for (a = j = 0, ref = numLines; j < ref; a = j += 1) {
        for (b = k = ref1 = a + 1, ref2 = numLines; k < ref2; b = k += 1) {
          lines[a].intersect(lines[b]);
        }
      }
    };

    return Intersector;

  })();


  /*
  Event Priority Queue methods.
   */

  BDS.Intersector.EventPQ = (function() {
    function EventPQ(lines) {
      var enter, events, exit, i, j, len, line, p1, p2, ref;
      events = [];
      len = lines.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        line = lines[i];
        enter = new BDS.Intersector.Event();
        exit = new BDS.Intersector.Event();
        p1 = line.p1;
        p2 = line.p2;
        if (p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y)) {
          this._populateEvent(enter, exit, p1, p2, line, i);
        } else {
          this._populateEvent(enter, exit, p2, p1, line, i);
        }
        events.push(enter);
        events.push(exit);
      }
      this.PQ = new BDS.Heap(events, BDS.Intersector.Event_Comparator);
    }

    EventPQ.prototype._populateEvent = function(enter, exit, p1, p2, line, id) {
      enter.type = BDS.Intersector.Event.ENTER;
      exit.type = BDS.Intersector.Event.EXIT;
      enter.x = p1.x;
      enter.y = p1.y;
      exit.x = p2.x;
      exit.y = p2.y;
      enter.line = line;
      exit.line = line;
      enter.id = id;
      exit.id = id;
      enter.twin = exit;
      return exit.twin = enter;
    };

    EventPQ.prototype.delMin = function() {
      return this.PQ.dequeue();
    };

    EventPQ.prototype.isEmpty = function() {
      return this.PQ.isEmpty();
    };

    EventPQ.prototype.size = function() {
      return this.PQ.size();
    };

    return EventPQ;

  })();

  BDS.Intersector.Event_Comparator = function(e1, e2) {
    if (e1.line === e2.line && e1.type === e2.type) {
      return true;
    }
    if (e1.line === e2.line) {
      return e1.type === BDS.Intersector.Event.ENTER;
    }
    if (e1.x < e2.x) {
      return true;
    }
    if (e1.x > e2.x) {
      return false;
    }
    if (e1.y < e2.y) {
      return true;
    }
    if (e1.y > e2.y) {
      return false;
    }
    if ((e1.type === BDS.Intersector.Event.EXIT) && (e2.type === BDS.Intersector.Event.ENTER)) {
      return true;
    }
    if ((e1.type === BDS.Intersector.Event.ENTER) && (e2.type === BDS.Intersector.Event.EXIT)) {
      return false;
    }
    if (e1.id <= e2.id) {
      return true;
    }
    return false;
  };

  BDS.Intersector.LineSweepSet = (function() {
    function LineSweepSet() {
      this.heap = new BDS.Heap([], BDS.Intersector.Event_Comparator);
    }

    LineSweepSet.prototype.add = function(event) {
      return this.heap.add(event);
    };

    LineSweepSet.prototype.remove = function(event_to_be_removed) {
      var err, my_event;
      my_event = this.heap.dequeue();
      if (my_event !== event_to_be_removed) {
        err = new Error("ERROR: line_tuple exit ordering is messed up!");
        console.log(err.stack);
        debugger;
        throw err;
      }
      return my_event;
    };

    LineSweepSet.prototype.intersect_with_line = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref, results;
      len = this.heap.size();
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        results.push(input_line.intersect(line_crossing_sweep));
      }
      return results;
    };

    LineSweepSet.prototype.detect_intersection_with_line_partitioned = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref;
      len = this.heap.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        if (line_crossing_sweep.points === input_line.points) {
          continue;
        }
        if (input_line.detect_intersection(line_crossing_sweep)) {
          return true;
        }
      }
      return false;
    };

    LineSweepSet.prototype.detect_intersection_with_line = function(input_line) {
      var event, i, j, len, line_crossing_sweep, ref;
      len = this.heap.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        event = this.heap.getElem(i);
        line_crossing_sweep = event.line;
        if (input_line.detect_intersection(line_crossing_sweep)) {
          return true;
        }
      }
      return false;
    };

    return LineSweepSet;

  })();

  BDS.Intersector.Event = (function() {
    Event.ENTER = 0;

    Event.EXIT = 1;

    function Event() {
      this.type = null;
      this.x = null;
      this.y = null;
      this.id = null;
      this.twin = null;
    }

    return Event;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Line with associated intersection data.
Written by Bryce Summers on 1 - 2 - 2017.

This class is designed for intersection techniques and line segment splitting,
rather than for simply representing a line segment.
Please use Polylines for the geometric representation and drawing of lines.
 */

(function() {
  BDS.Line = (function() {
    function Line(start_point_index, end_point_index, point_array) {
      this.p1_index = start_point_index;
      this.p2_index = end_point_index;
      this.points = point_array;
      this.p1 = this.points[this.p1_index];
      this.p2 = this.points[this.p2_index];
      if (this.p2 === void 0) {
        debugger;
      }
      this.offset = this.p2.sub(this.p1);
      this.split_points_per = [];
      this.split_points_indices = [];

      /* reserved space for attribute data that may be associated to 
       * higher order information about where the intersection occured.
      @_curve = undefined # A curve that this Line was sampled from.
      @_time1, @_time2 # The start and ending parameters.
       */
    }

    Line.prototype.setAssociatedCurve = function(obj) {
      this._curve = obj;
    };

    Line.prototype.getAssociatedCurve = function() {
      return this._curve;
    };

    Line.prototype.hasAssociatedCurve = function() {
      return this._curve !== void 0;
    };

    Line.prototype.setTimes = function(time1, time2) {
      this._time1 = time1;
      this._time2 = time2;
    };

    Line.prototype.getTimes = function() {
      if (this._time1 === void 0) {
        return void 0;
      }
      return [this._time1, this._time2];
    };


    /*
    intersects the given other_line with this line.
    Adds a split point if they do intersect.
    Any created split points are added to the referenced global collection of points.
     * Line -> bool
     */

    Line.prototype.intersect = function(other) {
      if (this.points === other.points && (this.p1_index === other.p1_index || this.p1_index === other.p2_index || this.p2_index === other.p1_index || this.p2_index === other.p2_index)) {
        return false;
      }
      if (!this.detect_intersection(other)) {
        return false;
      }
      this._report_intersection(other);
      return true;
    };


    /*
    Returns a signed floating point number indicating which direction the given point is relative to this line.
     * Point -> float.
     */

    Line.prototype.line_side_test = function(c) {
      return (this.p2.x - this.p1.x) * (c.y - this.p1.y) - (this.p2.y - this.p1.y) * (c.x - this.p1.x);
    };


    /*
    Appends all of the split set of lines in order to the output vector.
    Adds itself if it does not contain any split lines.
    Line pts are oriented along the polyline, such that p1 comes before p2 in the polyline + intersection point ordering.
    Line[] -> void
     */

    Line.prototype.getSplitLines = function(lines_out) {
      var ass_data, i, i_line, j, last_indice, len, next_indice, ref, times;
      len = this.split_points_per.length;
      if (len === 0) {
        lines_out.push(this);
        return;
      }
      ass_data = false;
      if (this._time1 && this._time2) {
        ass_data = true;
        times = this.getAllIntersectionTimes(times);
      }
      this._sort_split_points();
      this.split_points_indices.push(this.p2_index);
      last_indice = this.split_points_indices[0];
      i_line = new BDS.Line(this.p1_index, last_indice, this.points);
      if (ass_data) {
        i_line.setAssociatedCurve(this._curve);
        i_line.setTimes(this._time1, times[0]);
      }
      lines_out.push(i_line);
      for (i = j = 1, ref = len; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        next_indice = this.split_points_indices[i];
        i_line = new BDS.Line(last_indice, next_indice, this.points);
        if (ass_data) {
          i_line.setAssociatedCurve(this._curve);
          i_line.setTimes(times[i - 1], times[i]);
        }
        lines_out.push(i_line);
        last_indice = next_indice;
      }
      i_line = new BDS.Line(last_indice, this.p2_index, this.points);
      if (ass_data) {
        i_line.setAssociatedCurve(this._curve);
        i_line.setTimes(times[len - 1], this._time2);
      }
      lines_out.push(i_line);
    };


    /*
    This function should only be called after a call to intersect has returned true.
    Returns the last intersection point.
    this is only guranteed to be valid immediatly after the true return from the intersect function.
    void -> Point.
     */

    Line.prototype.getLatestIntersectionPoint = function() {
      return this.points[this.points.length - 1];
    };

    Line.prototype.getAllIntersectionPoints = function(out) {
      var index, j, len1, ref;
      if (out === void 0) {
        out = [];
      }
      ref = this.split_points_indices;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        index = ref[j];
        out.push(this.points[index]);
      }
      return out;
    };

    Line.prototype.getAllIntersectionTimes = function(out) {
      var j, len1, per, ref;
      if (out === void 0) {
        out = [];
      }
      ref = this.split_points_per;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        per = ref[j];
        out.push(BDS.Math.lerp(this._time1, this._time2, per));
      }
      return out;
    };


    /*
    Internally sorts the split points from the start to the end of this line.
     */

    Line.prototype._sort_split_points = function() {
      var i, i1, i2, j, k, len, ref, ref1, temp_f, temp_i;
      len = this.split_points_per.length;
      for (i = j = 1, ref = len; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        for (i2 = k = ref1 = i - 1; ref1 <= 0 ? k <= 0 : k >= 0; i2 = ref1 <= 0 ? ++k : --k) {
          i1 = i2 + 1;
          if (this.split_points_per[i2] <= this.split_points_per[i1]) {
            break;
          }
          temp_f = this.split_points_per[i2];
          this.split_points_per[i2] = this.split_points_per[i1];
          this.split_points_per[i1] = temp_f;
          temp_i = this.split_points_indices[i2];
          this.split_points_indices[i2] = this.split_points_indices[i1];
          this.split_points_indices[i1] = temp_i;
        }
      }
    };


    /*
    Returns true iff this line segment intersects with the other line segment.
    Doesn't do any degeneracy checking.
    Line -> bool.
     */

    Line.prototype.detect_intersection = function(other) {
      var a1, a2, a_opposites, b1, b2, b_opposites;
      a1 = this.line_side_test(other.p1);
      a2 = this.line_side_test(other.p2);
      b1 = other.line_side_test(this.p1);
      b2 = other.line_side_test(this.p2);

      /*
      The product of two point based line side tests will be negative iff
      the points are not on strictly opposite sides of the line.
      If the product is 0, then at least one of the points is on the line not containing the points.
       */

      /*
      epsilon = .001
      a_on = (Math.abs(a1) < epsilon or Math.abs(a2) < epsilon)
      b_on = (Math.abs(b1) < epsilon or Math.abs(b2) < epsilon)
       */
      a_opposites = a1 * a2 <= 0;
      b_opposites = b1 * b2 <= 0;
      if ((a_opposites && b_opposites) && (a1 !== 0 || a2 !== 0)) {
        return true;
      }

      /*
                     (a_opposites and b_on) or
                     (a_on and b_opposites)
       */
    };


    /*
    Line -> void.
     */

    Line.prototype._report_intersection = function(other) {

      /*
      u = ((bs.y - as.y) * bd.x - (bs.x - as.x) * bd.y) / (bd.x * ad.y - bd.y * ad.x)
      v = ((bs.y - as.y) * ad.x - (bs.x - as.x) * ad.y) / (bd.x * ad.y - bd.y * ad.x)
      Factoring out the common terms, this comes to:
      
      dx = bs.x - as.x
      dy = bs.y - as.y
      det = bd.x * ad.y - bd.y * ad.x
      u = (dy * bd.x - dx * bd.y) / det
      v = (dy * ad.x - dx * ad.y) / det
       */
      var ad, as, bd, bs, det, dx, dy, index, intersection_point, u, v;
      as = this.p1;
      bs = other.p1;
      ad = this.offset;
      bd = other.offset;
      dx = bs.x - as.x;
      dy = bs.y - as.y;
      det = bd.x * ad.y - bd.y * ad.x;
      u = (dy * bd.x - dx * bd.y) / det;
      v = (dy * ad.x - dx * ad.y) / det;
      this.split_points_per.push(u);
      other.split_points_per.push(v);
      intersection_point = as.add(ad.multScalar(u));
      if (isNaN(intersection_point.x)) {
        debugger;
      }
      index = this.points.length;
      this.points.push(intersection_point);
      this.split_points_indices.push(index);
      return other.split_points_indices.push(index);
    };

    Line.prototype.clearIntersections = function() {
      this.split_points_per = [];
      return this.split_points_indices = [];
    };

    Line.prototype.getNormal = function(pt) {
      var dir, normal, temp;
      normal = this.offset.normalize();
      temp = normal.x;
      normal.x = -normal.y;
      normal.y = temp;
      dir = pt.sub(this.p1);
      if (normal.dot(dir) < 0) {
        return normal.multScalar(-1);
      }
      return normal;
    };

    return Line;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
BDS.Math.Coffee
Written by Bryce Summers on 2 - 27 - 2017.
Purpose: Provides useful functions, such as Lerping.
 */

(function() {
  BDS.Math = {};

  BDS.Math.lerp = function(from, to, percentage) {
    return from * (1 - percentage) + to * percentage;
  };

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  BDS.Bezier_Curve = (function() {
    function Bezier_Curve(pt1, tan1, pt2, tan2, input_coefs) {
      if (input_coefs !== void 0 && input_coefs === true) {
        this._A = pt1.clone();
        this._B = tan1.clone();
        this._C = pt2.clone();
        this._D = tan2.clone();
        return;
      }
      this._A = pt1.multScalar(2).sub(pt2.multScalar(2)).add(tan1).add(tan2);
      this._B = pt1.multScalar(-3).add(pt2.multScalar(3)).sub(tan1.multScalar(2)).sub(tan2);
      this._C = tan1.clone();
      this._D = pt1.clone();
    }

    Bezier_Curve.prototype.subCurve = function(t1, t2) {
      var A_new, B_new, C_new, D_new, output, scale_a, scale_b, scale_c, scale_d, t1_2, t1_3, t2_2, t2_3;
      t1_2 = t1 * t1;
      t1_3 = t1 * t1 * t1;
      t2_2 = t2 * t2;
      t2_3 = t2 * t2 * t2;
      scale_a = -t1_3 + t2_3 - 3 * t1 * t2_2 + 3 * t1_2 * t2;
      A_new = this._A.multScalar(scale_a);
      scale_a = t1_3 + 3 * t1 * t2_2 - 6 * t1_2 * t2;
      scale_b = t1_2 + t2_2 - 2 * t1 * t2;
      B_new = this._A.multScalar(scale_a).add(this._B.multScalar(scale_b));
      scale_a = -3 * t1_3 + 3 * t1_2 * t2;
      scale_b = -2 * t1_2 + 2 * t1 * t2;
      scale_c = t2 - t1;
      C_new = this._A.multScalar(scale_a).add(this._B.multScalar(scale_b)).add(this._C.multScalar(scale_c));
      scale_a = t1_3;
      scale_b = t1_2;
      scale_c = t1;
      scale_d = 1;
      D_new = this._A.multScalar(scale_a).add(this._B.multScalar(scale_b)).add(this._C.multScalar(t1)).add(this._D);
      output = new BDS.Bezier_Curve(A_new, B_new, C_new, D_new, true);
      return output;
    };

    Bezier_Curve.prototype.position = function(t) {
      return this._A.multScalar(t).add(this._B).multScalar(t).add(this._C).multScalar(t).add(this._D);
    };

    Bezier_Curve.prototype.tangent = function(t) {
      return this._A.multScalar(3 * t).add(this._B.multScalar(2)).multScalar(t).add(this._C);
    };

    Bezier_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    Bezier_Curve.prototype.toPolyline = function(max_length_per_segment, times_output) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this.position(0);
      output.push(p0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.position(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.position(high);
        while (p_low.distanceTo(p_high) > max_length_per_segment) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.position(high);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return new BDS.Polyline(false, output);
    };

    Bezier_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    return Bezier_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Box.

Written by Bryce Summers on 1 - 5 - 2017
 */

(function() {
  BDS.Box = (function() {
    function Box(min, max, _isFilled) {
      this.min = min;
      this.max = max;
      this._isFilled = _isFilled;
      if (!this.min) {
        this.min = new BDS.Point(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      }
      if (!this.max) {
        this.max = new BDS.Point(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
      }
      if (!this._isFilled) {
        this._isFilled = true;
      }
    }

    Box.prototype.clone = function() {
      return new BDS.Box(this.min.clone(), this.max.clone());
    };

    Box.prototype.isFilled = function() {
      return this._isFilled;
    };

    Box.prototype.expandByPoint = function(p) {
      this.min = this.min.min(p);
      return this.max = this.max.max(p);
    };

    Box.prototype.union = function(box) {
      var out;
      out = this.clone();
      out.min = this.min.min(box.min);
      out.max = this.max.max(box.max);
      return out;
    };

    Box.prototype.intersect = function(box) {
      var out;
      out = this.clone();
      out.min = this.min.max(box.min);
      out.max = this.max.min(box.max);
      return out;
    };

    Box.prototype.containsPoint = function(pt) {
      return pt.greaterThanOrEqual(this.min) && pt.lessThanOrEqual(this.max);
    };

    Box.prototype.getRandomPointInBox = function() {
      var range, x, y, z;
      range = this.max.sub(this.min);
      x = this.min.x + Math.random() * range.x;
      y = this.min.y + Math.random() * range.y;
      z = this.min.z + Math.random() * range.z;
      return new BDS.Point(x, y, z);
    };

    Box.prototype.area = function() {
      var area, diff;
      diff = this.max.sub(this.min);
      area = Math.abs(diff.x * diff.y);
      if (diff.x < 0 || diff.y < 0) {
        area = -area;
      }
      return area;
    };

    Box.prototype.intersects_box = function(box) {
      var intersection;
      intersection = this.intersect(box);
      return intersection.area() >= 0;
    };

    Box.prototype.toPolyline = function() {
      var p0, p1, p2, p3, points, polyline;
      p0 = this.min.clone();
      p1 = this.min.clone();
      p1.x = this.max.x;
      p2 = this.max.clone();
      p3 = this.min.clone();
      p3.y = this.max.y;
      points = [p0, p1, p2, p3];
      polyline = new BDS.Polyline(true, points, this._isFilled);
      return polyline;
    };

    return Box;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*

Circle Class
Written by Bryce Summers on 1 - 6 - 2017.
 */

(function() {
  BDS.Circle = (function() {
    function Circle(_center, _radius, filled) {
      this._center = _center;
      this._radius = _radius;
      this.filled = filled;
      if (this.filled === void 0) {
        this.filled = false;
      }

      /*
      @_boundingbox, stored the bounding box.
       */
    }

    Circle.prototype.isFilled = function() {
      return this.filled;
    };

    Circle.prototype.setPosition = function(x, y) {
      this._center.x = x;
      return this._center.y = y;
    };

    Circle.prototype.getPosition = function() {
      return this._center.clone();
    };

    Circle.prototype.getRadius = function() {
      return this._radius;
    };

    Circle.prototype.minnimum_time_of_intersection_with_ray = function(ray) {
      var det, det_sqr, l, loc, o, o_sub_c, o_sub_c_sqr, time1, time2;
      o = ray.getPoint();
      l = ray.getDirection();
      o_sub_c = o.sub(this._center);
      o_sub_c_sqr = o_sub_c.dot(o_sub_c);
      if (this.filled && Math.sqrt(o_sub_c_sqr) < this._radius) {
        return 0;
      }
      loc = o_sub_c.dot(l);
      det_sqr = loc * loc - o_sub_c_sqr + this._radius * this._radius;
      if (det_sqr < 0) {
        return null;
      }
      det = Math.sqrt(det_sqr);
      time1 = -loc + det;
      time2 = -loc - det;
      if (time2 > 0) {
        return time2;
      }
      if (time1 > 0) {
        return time1;
      }
      return null;
    };

    Circle.prototype.detect_intersection_with_polyline = function(polyline) {
      var i, intersection_time, len, pt, ray, rays;
      if (polyline.size < 1) {
        return false;
      }
      if (this.filled) {
        pt = polyline.getPoint(0);
        if (this.containsPoint(pt)) {
          return true;
        }
      }
      if (polyline.isFilled()) {
        if (polyline.containsPoint(this._center)) {
          return true;
        }
      }
      rays = polyline.toRays();
      for (i = 0, len = rays.length; i < len; i++) {
        ray = rays[i];
        intersection_time = this.minnimum_time_of_intersection_with_ray(ray);
        if (intersection_time !== null && intersection_time < ray.getTimeScale()) {
          return true;
        }
        continue;
      }
      return false;
    };

    Circle.prototype.containsPoint = function(pt) {
      var diff, dist;
      diff = pt.sub(this._center);
      dist = diff.norm();
      return dist < this._radius;
    };

    Circle.prototype.generateBoundingBox = function() {
      var max, min;
      this._boundingbox = new BDS.Box();
      min = this._center.clone();
      min.x -= this._radius;
      min.y -= this._radius;
      max = this._center.clone();
      max.x += this._radius;
      max.y += this._radius;
      this._boundingbox.expandByPoint(min);
      this._boundingbox.expandByPoint(max);
      return this._boundingbox;
    };

    Circle.prototype.getBoundingBox = function() {
      return this._boundingbox;
    };

    return Circle;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  BDS.Curve = (function() {
    function Curve(spline) {
      this._spline = spline;
      this._point_discretization = [];
    }

    Curve.prototype.addPoint = function(p) {
      return this._spline.points.push(p);
    };

    Curve.prototype.numPoints = function(p) {
      return this._spline.points.length;
    };

    Curve.prototype.getPointAtIndex = function(i) {
      return this._spline.points[i];
    };

    Curve.prototype.getLastPoint = function() {
      return this.getPointAtIndex(this.numPoints() - 1);
    };

    Curve.prototype.removeLastPoint = function() {
      return this._spline.points.pop();
    };

    Curve.prototype.position = function(t) {
      return this._spline.getPoint(t);
    };

    Curve.prototype.tangent = function(t) {
      return this._spline.getTangent(t);
    };

    Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    Curve.prototype.updateDiscretization = function(max_length) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this._spline.getPoint(0);
      output.push(p0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this._spline.getPoint(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this._spline.getPoint(high);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this._spline.getPoint(high);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return this._discretization = output;
    };

    Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    return Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Geometry Super Class
Written by Bryce Summers on 1 - 9 - 2017.

This class abstract away many common procedures and specifies a common interface for algorithms on geometries.
 */

(function() {
  BDS.Geometry = (function() {
    function Geometry(closed, filled) {
      this.closed = closed;
      this.filled = filled;
    }

    Geometry.prototype.generateBoundingBox = function() {};

    Geometry.prototype.containsPoint = function(pt) {};

    Geometry.prototype.detect_intersection_with_polyline = function(polyline) {
      throw new Error("Please Override Me!");
    };

    return Geometry;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Point.

Written by Bryce Summers on 1 - 2 - 2017.

Implements Arithmetic.

add, sub, multScalar
 */

(function() {
  BDS.newDirection = function(x, y, z) {
    return new BDS.Point(x, y, z);
  };

  BDS.Point = (function() {
    function Point(x1, y1, z1) {
      this.x = x1;
      this.y = y1;
      this.z = z1;
      if (!this.z) {
        this.z = 0.0;
      }
    }

    Point.prototype.clone = function() {
      return new BDS.Point(this.x, this.y, this.z);
    };

    Point.prototype.add = function(pt) {
      var out;
      out = this.clone();
      out.x += pt.x;
      out.y += pt.y;
      out.z += pt.z;
      return out;
    };

    Point.prototype.sub = function(pt) {
      var out;
      out = this.clone();
      out.x -= pt.x;
      out.y -= pt.y;
      out.z -= pt.z;
      return out;
    };

    Point.prototype.multScalar = function(s) {
      var out;
      out = this.clone();
      out.x *= s;
      out.y *= s;
      out.z *= s;
      return out;
    };

    Point.prototype.divScalar = function(s) {
      var out;
      out = this.clone();
      out.x /= s;
      out.y /= s;
      out.z /= s;
      return out;
    };

    Point.prototype.toString = function() {
      var output;
      output = "Point(" + this.x + ", " + this.y;
      if (this.z) {
        output += ", " + this.z;
      }
      output += ")";
      return output;
    };

    Point.prototype.distanceTo = function(pt) {
      return pt.sub(this).norm();
    };

    Point.prototype.directionTo = function(pt) {
      return pt.sub(this).normalize();
    };

    Point.prototype.magnitude = function() {
      return this.norm();
    };

    Point.prototype.norm = function() {
      return Math.sqrt(this.norm2());
    };

    Point.prototype.norm2 = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };

    Point.prototype.min = function(pt) {
      var out;
      out = this.clone();
      out.x = Math.min(this.x, pt.x);
      out.y = Math.min(this.y, pt.y);
      out.z = Math.min(this.z, pt.z);
      return out;
    };

    Point.prototype.max = function(pt) {
      var out;
      out = this.clone();
      out.x = Math.max(this.x, pt.x);
      out.y = Math.max(this.y, pt.y);
      out.z = Math.max(this.z, pt.z);
      return out;
    };

    Point.prototype.normalize = function() {
      return this.divScalar(this.norm());
    };

    Point.prototype.dot = function(pt) {
      return pt.x * this.x + pt.y * this.y + pt.z * this.z;
    };

    Point.prototype.lessThan = function(pt) {
      return this.x < pt.x && this.y < pt.y && this.z < pt.z;
    };

    Point.prototype.lessThanOrEqual = function(pt) {
      return this.x <= pt.x && this.y <= pt.y && this.z <= pt.z;
    };

    Point.prototype.greaterThan = function(pt) {
      return this.x > pt.x && this.y > pt.y && this.z > pt.z;
    };

    Point.prototype.greaterThanOrEqual = function(pt) {
      return this.x >= pt.x && this.y >= pt.y && this.z >= pt.z;
    };

    return Point;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Polyline class (also represents polygons)

Written by Bryce Summers on 1 - 4 - 2017.

Note: Closed Polylines are polygons...
 - So we will put all of our polygon code into this class.

Note: this class assumes that it contains at least 1 point for collision tests.

Note: Polyline <--> polyline intersection tests assume that the polyline is not self intersecting.

FIXME: Return proper point in polyline tests for complemented filled polylines.
 */

(function() {
  BDS.Polyline = (function() {
    function Polyline(_isClosed, points_in, _isFilled) {
      this._isClosed = _isClosed;
      this._isFilled = _isFilled;
      if (this._isClosed === void 0) {
        this._isClosed = false;
      }
      if (this._isFilled === void 0) {
        this._isFilled = this._isClosed;
      }
      this._points = [];
      if (points_in) {
        this.appendPoints(points_in);
      }

      /*
       * These are commented out to save memory for applications that don't need these.
      @_boundingbox = null
      @_lineBVH = null
      @_obj # Associated Obj.
      @_times # List of parameter values that associated point for point.
       */
    }

    Polyline.prototype.appendPoints = function(array) {
      var j, len1, p;
      for (j = 0, len1 = array.length; j < len1; j++) {
        p = array[j];
        this.addPoint(p);
      }
    };

    Polyline.prototype.addPoint = function(p) {
      if (isNaN(p.x) || isNaN(p.y) || isNaN(p.z)) {
        debugger;
      }
      this._points.push(p);
      if (this._boundingbox) {
        this._boundingbox.expandByPoint(p);
      }
    };

    Polyline.prototype.removeLastPoint = function() {
      return this._points.pop();
    };

    Polyline.prototype.getPoint = function(index) {
      return this._points[index];
    };

    Polyline.prototype.size = function() {
      return this._points.length;
    };

    Polyline.prototype.isClosed = function() {
      return this._isClosed;
    };

    Polyline.prototype.isFilled = function() {
      return this._isFilled;
    };


    /*
    * http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/
    * Computes the area of a 2D polygon directly from the polygon's coordinates.
    * The area will be positive or negative depending on the
    * clockwise / counter clockwise orientation of the points.
    * Also see: https://brycesummers.wordpress.com/2015/08/24/a-proof-of-simple-polygonal-area-via-greens-theorem/
    * Note: This function interprets this polyline as closed.
     *  -> float
     */

    Polyline.prototype.computeArea = function() {
      var area, i, j, len, p1, p2, ref;
      len = this._points.length;
      p1 = this._points[len - 1];
      area = 0.0;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        p2 = this._points[i];
        area += (p2.x + p1.x) * (p2.y - p1.y);
        p1 = p2;
      }
      return -area / 2.0;
    };

    Polyline.prototype.isComplemented = function() {
      return this.computeArea() <= 0.0000001;
    };

    Polyline.prototype.ensureBoundingBox = function() {
      if (this._boundingbox === void 0) {
        this.generateBoundingBox();
      }
      return this._boundingbox;
    };

    Polyline.prototype.generateBoundingBox = function(polygon) {
      var j, len1, pt, ref;
      this._boundingbox = new BDS.Box();
      ref = this._points;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        pt = ref[j];
        this._boundingbox.expandByPoint(pt);
        if (isNaN(this._boundingbox.min.x)) {
          debugger;
        }
      }
      return this._boundingbox;
    };

    Polyline.prototype.getBoundingBox = function() {
      return this._boundingbox;
    };

    Polyline.prototype.setAssociatedData = function(obj) {
      this._obj = obj;
    };

    Polyline.prototype.getAssociatedData = function() {
      return this._obj;
    };

    Polyline.prototype.setTimes = function(times) {
      var err;
      if (times.length !== this._points.length) {
        debugger;
        err = new Error();
        console.log(err.stacktrace());
        throw err;
      }
      return this._times = times;
    };

    Polyline.prototype.getTimes = function(times) {
      return this._times;
    };


    /*
    getBVH: () ->
        return @_lineBVH()
     */

    Polyline.prototype.toPolylineSegments = function(output) {
      var i, j, len, p0, p1, ref;
      if (output === void 0) {
        output = [];
      }
      len = this._points.length;
      for (i = j = 0, ref = len - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p0 = this._points[i];
        p1 = this._points[i + 1];
        output.push(new BDS.Polyline(false, [p0, p1]));
      }
      if (this._isClosed) {
        p0 = this._points[len - 1];
        p1 = this._points[0];
        output.push(new BDS.Polyline(false, [p0, p1]));
      }
      return output;
    };

    Polyline.prototype._toLineSegments = function() {
      var i, j, len, line, output, points, ref;
      output = [];
      points = this._points.slice(0);
      len = points.length;
      for (i = j = 0, ref = len - 1; j < ref; i = j += 1) {
        line = new BDS.Line(i, i + 1, points);
        line.p1_index;
        line.p2_index;
        output.push(line);
      }
      if (this._isClosed) {
        line = new BDS.Line(len - 1, 0, points);
        line.p1_index;
        line.p2_index;
        output.push(line);
      }
      return output;
    };

    Polyline.prototype.toRays = function(output) {
      var dir, i, j, len, p0, p1, ref;
      if (output === void 0) {
        output = [];
      }
      len = this._points.length;
      for (i = j = 0, ref = len - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        p0 = this._points[i];
        p1 = this._points[i + 1];
        dir = p1.sub(p0);
        output.push(new BDS.Ray(p0, dir));
      }
      if (this._isClosed) {
        p0 = this._points[len - 1];
        p1 = this._points[0];
        dir = p1.sub(p0);
        output.push(new BDS.Ray(p0, dir));
      }
      return output;
    };

    Polyline.prototype.containsPoint = function(pt) {
      if (this._lineBVH) {
        throw new ERROR("Implement me Please!");
      } else {
        return this._point_in_polygon_test(pt);
      }
    };

    Polyline.prototype._point_in_polygon_test = function(pt) {
      var j, len1, odd, ray, segment, segments;
      ray = new BDS.Ray(pt, BDS.newDirection(1.0, 0));
      odd = false;
      segments = this._toLineSegments();
      for (j = 0, len1 = segments.length; j < len1; j++) {
        segment = segments[j];
        if (ray.detect_intersection_with_line(segment)) {
          odd = !odd;
        }
      }
      return odd;
    };

    Polyline.prototype.detect_intersection_with_box = function(box) {
      var polyline;
      if (this._boundingbox === void 0) {
        this.generateBoundingBox();
      }
      if (!box.intersects_box(this._boundingbox)) {
        return false;
      }
      if (this.isFilled() && this.containsPoint(box.min)) {
        return true;
      }
      if (box.isFilled() && box.containsPoint(this._points[0])) {
        return true;
      }
      polyline = box.toPolyline();
      return this.detect_intersection_with_polyline(polyline);
    };

    Polyline.prototype.detect_intersection_with_polyline = function(polyline) {
      var all_lines, intersector, lines1, lines2;
      lines1 = this._toLineSegments();
      lines2 = polyline._toLineSegments();
      all_lines = lines1.concat(lines2);
      intersector = new BDS.Intersector();
      return intersector.detect_intersection_line_segments_partitioned(all_lines);
    };

    Polyline.prototype.report_intersections_with_polyline = function(polyline) {
      var all_lines, intersector, j, len1, line, lines1, lines2, out;
      lines1 = this._toLineSegments();
      lines2 = polyline._toLineSegments();
      all_lines = lines1.concat(lines2);
      intersector = new BDS.Intersector();
      intersector.intersectLineSegments(all_lines);
      out = [];
      for (j = 0, len1 = all_lines.length; j < len1; j++) {
        line = all_lines[j];
        line.getAllIntersectionPoints(out);
      }
      return out;
    };

    Polyline.prototype.splitPolyline = function(pt, split_index) {
      var i, j, k, left, left_out, ref, ref1, ref2, right, right_out;
      if (split_index === void 0) {
        split_index = 0;
      }
      left = [];
      right = [];
      for (i = j = 0, ref = split_index; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        left.push(this._points[i]);
      }
      left.push(pt);
      right.push(pt);
      for (i = k = ref1 = split_index + 1, ref2 = this._points.length; ref1 <= ref2 ? k < ref2 : k > ref2; i = ref1 <= ref2 ? ++k : --k) {
        right.push(this._points[i]);
      }
      left_out = new Polyline(false, left);
      right_out = new Polyline(false, right);
      return [left_out, right_out];
    };

    return Polyline;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Ray Class.

Written by Bryce Summers on 1 - 6 - 2017.

Purpose:
 */

(function() {
  BDS.Ray = (function() {
    function Ray(point, dir, _time_scale) {
      this.dir = dir;
      this._time_scale = _time_scale;
      if (this._time_scale === void 0) {
        this._time_scale = this.dir.norm();
        this.dir = this.dir.divScalar(this._time_scale);
      } else {
        this.dir = this.dir.normalize();
      }
      this.p1 = point;
      this.p2 = this.p1.add(this.dir);
    }

    Ray.prototype.getPoint = function() {
      return this.p1.clone();
    };

    Ray.prototype.getDirection = function() {
      return this.dir;
    };

    Ray.prototype.getTimeScale = function() {
      return this._time_scale;
    };

    Ray.prototype.detect_intersection_with_line = function(line) {
      var correct_direction, normal, side1, side2;
      side1 = this.line_side_test(line.p1);
      side2 = this.line_side_test(line.p2);
      normal = line.getNormal(this.p1);
      correct_direction = normal.dot(this.dir) < 0;
      return side1 * side2 <= 0 && correct_direction;
    };

    Ray.prototype.line_side_test = function(c) {
      return (this.p2.x - this.p1.x) * (c.y - this.p1.y) - (this.p2.y - this.p1.y) * (c.x - this.p1.x);
    };

    Ray.prototype.getAngle = function() {
      return Math.atan2(this.p2.y - this.p1.y, this.p2.x - this.p1.x);
    };

    return Ray;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  BDS.BVH2D = (function() {
    BVH2D.MAX_OBJECTS_PER_LEAF = 4;

    function BVH2D(polygons, xy) {
      var i, j, left_partition, ref, ref1, right_partition;
      if (!xy) {
        xy = {
          val: 'x'
        };
      }
      this._leafs = [];
      this._leaf_node = false;
      this._size = polygons.length;
      this._ensure_bounding_boxes(polygons);
      this._AABB = this._compute_AABB(polygons);
      if (polygons.length < BDS.BVH2D.MAX_OBJECTS_PER_LEAF) {
        this._leaf_node = true;
        this._leafs = [];
        for (i = j = 0, ref = polygons.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(polygons[i]);
        }
        return;
      }
      if (xy.dim === 2) {
        this._AABB.min.z = -1;
        this._AABB.max.z = +1;
      }
      polygons = this._sort_polygon_list(polygons, xy);
      ref1 = this._partition_by_SA(polygons), left_partition = ref1[0], right_partition = ref1[1];
      xy.val = this._nextXY(xy);
      this._left = new BDS.BVH2D(left_partition, xy);
      this._right = new BDS.BVH2D(right_partition, xy);
    }

    BVH2D.prototype._copy_from = function(bvh) {
      this._leaf_node = bvh._leaf_node;
      this._size = bvh._size;
      this._AABB = bvh._AABB;
      this._leafs = bvh._leafs;
      this._left = bvh._left;
      return this._right = bvh._right;
    };


    /*
     - Private Construction Methods. -----------------------
     */

    BVH2D.prototype._sort_polygon_list = function(polygon_list, xy) {
      var centroid_index_list, i, j, len, output, polygon_index, ref, sort_function;
      centroid_index_list = this._centroid_index_list(polygon_list);
      sort_function = function(a, b) {
        switch (xy.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
        }
        debugger;
        return console.log("xy is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = polygon_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon_index = centroid_index_list[i].index;
        output.push(polygon_list[polygon_index]);
      }
      return output;
    };

    BVH2D.prototype._nextXY = function(xy) {
      switch (xy.val) {
        case 'x':
          return 'y';
        case 'y':
          return 'x';
      }
      debugger;
      console.log("xy is malformed.");
      debugger;
      return console.log("Case not handled.");
    };

    BVH2D.prototype._centroid_index_list = function(polygon_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = polygon_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(polygon_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    BVH2D.prototype._computeCentroid = function(polygon) {
      var centroid, i, j, len, point, ref;
      centroid = new BDS.Point(0, 0);
      len = polygon.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        point = polygon.getPoint(i);
        centroid = centroid.add(point);
      }
      return centroid.divScalar(len);
    };

    BVH2D.prototype._partition_by_SA = function(polygon_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [polygon_list[0]];
      right = [];
      i0 = polygon_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(polygon_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(polygon_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(polygon_list[i]);
      }
      return [left, right];
    };

    BVH2D.prototype._ensure_bounding_boxes = function(polygon_list) {
      var j, len1, polygon, results;
      results = [];
      for (j = 0, len1 = polygon_list.length; j < len1; j++) {
        polygon = polygon_list[j];
        results.push(polygon.generateBoundingBox());
      }
      return results;
    };

    BVH2D.prototype._compute_AABB = function(polygon_list) {
      var AABB, i, j, output, polygon, ref;
      output = new BDS.Box();
      for (i = j = 0, ref = polygon_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon = polygon_list[i];
        AABB = polygon.getBoundingBox();
        output = output.union(AABB);
      }
      return output;
    };

    BVH2D.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };

    BVH2D.prototype.query_point = function(pt) {
      var j, len1, polygon, ref, result;
      if (this._leaf_node) {
        ref = this._leafs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          polygon = ref[j];
          if (polygon.isClosed() && polygon.containsPoint(pt)) {
            return polygon;
          }
        }
        return null;
      }
      if (this._AABB.containsPoint(pt)) {
        result = this._left.query_point(pt);
        if (result !== null) {
          return result;
        }
        result = this._right.query_point(pt);
        return result;
      }
      return null;
    };

    BVH2D.prototype.query_point_all = function(pt, output_list) {
      var j, len1, polygon, ref;
      if (output_list === void 0) {
        output_list = [];
      }
      if (this._leaf_node) {
        ref = this._leafs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          polygon = ref[j];
          if (polygon.isClosed() && polygon.containsPoint(pt)) {
            output_list.push(polygon);
          }
        }
        return output_list;
      }
      if (this._AABB.containsPoint(pt)) {
        this._left.query_point_all(pt, output_list);
        this._right.query_point_all(pt, output_list);
      }
      return output_list;
    };

    BVH2D.prototype.query_box_all = function(query_box, output_list) {
      var j, len1, polygon, ref;
      if (output_list === void 0) {
        output_list = [];
      }
      if (this._leaf_node) {
        ref = this._leafs;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          polygon = ref[j];
          if (polygon.detect_intersection_with_box(query_box)) {
            output_list.push(polygon);
          }
          continue;
        }
        return output_list;
      }
      if (this._AABB.intersects_box(query_box)) {
        this._left.query_box_all(query_box, output_list);
        this._right.query_box_all(query_box, output_list);
      }
      return output_list;
    };

    BVH2D.prototype.toPolylines = function() {
      var polylines;
      polylines = [];
      this._toPolylines(polylines);
      return polylines;
    };

    BVH2D.prototype._toPolylines = function(output) {
      var max, max_x, max_y, min, min_x, min_y, p0, p1, p2, p3, polyline;
      min = this._AABB.min;
      max = this._AABB.max;
      min_x = min.x;
      min_y = min.y;
      max_x = max.x;
      max_y = max.y;
      p0 = new BDS.Point(min_x, min_y, 0);
      p1 = new BDS.Point(max_x, min_y, 0);
      p2 = new BDS.Point(max_x, max_y, 0);
      p3 = new BDS.Point(min_x, max_y, 0);
      polyline = new BDS.Polyline(true, [p0, p1, p2, p3]);
      output.push(polyline);
      if (!this._leaf_node) {
        this._left._toPolylines(output);
        this._right._toPolylines(output);
      }
    };

    BVH2D.prototype.optimize = function() {};

    BVH2D.prototype.add = function(polyline) {
      var potential_bb_left, potential_bb_right, sa_diff_left, sa_diff_right;
      polyline.ensureBoundingBox();
      if (this._leaf_node) {
        this._leafs.push(polyline);
        this._AABB = this._AABB.union(polyline.getBoundingBox());
        this._size++;
        return;
      }
      potential_bb_left = this._left._AABB.union(polyline.getBoundingBox());
      potential_bb_right = this._right._AABB.union(polyline.getBoundingBox());
      sa_diff_left = this._compute_SA(potential_bb_left) - this._compute_SA(this._left._AABB);
      sa_diff_right = this._compute_SA(potential_bb_right) - this._compute_SA(this._right._AABB);
      if (sa_diff_left < sa_diff_right) {
        this._left.add(polyline);
      } else {
        this._right.add(polyline);
      }
      this._AABB = this._left._AABB.union(this._right._AABB);
      this._size++;
    };

    BVH2D.prototype.remove = function(polyline) {
      var j, len1, old_line, old_lines, polyline_bb, removed;
      polyline.ensureBoundingBox();
      polyline_bb = polyline.getBoundingBox();
      if (!polyline_bb.intersects_box(this._AABB)) {
        return false;
      }
      if (this._leaf_node) {
        this._AABB = new BDS.Box();
        old_lines = this._leafs;
        this._leafs = [];
        removed = false;
        for (j = 0, len1 = old_lines.length; j < len1; j++) {
          old_line = old_lines[j];
          if (polyline === old_line) {
            removed = true;
            this._size--;
            continue;
          }
          this._AABB = this._AABB.union(old_line.getBoundingBox());
          this._leafs.push(old_line);
        }
        return removed;
      }
      removed = this._left.remove(polyline);
      if (!removed) {
        removed = this._right.remove(polyline);
      }
      if (!removed) {
        return false;
      }
      this._size--;
      if (this._size === 0) {
        this._leaf_node = true;
        this._leafs = [];
        this._left = void 0;
        this._right = void 0;
        return removed;
      }
      if (this._left._size === 0) {
        this._copy_from(this._right);
        return true;
      }
      if (this._right._size === 0) {
        this._copy_from(this._left);
        return true;
      }
      this._AABB = this._left._AABB.union(this._right._AABB);
      return true;
    };

    return BVH2D;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Double Linked List Class
 * Written as part of the Bryce Summers Javascript Data Structures Libary.
 * Written by Bryce Summers on 1/3/2017.
 */

(function() {
  BDS.DoubleLinkedList = (function() {
    function DoubleLinkedList() {
      this.clear();
    }

    DoubleLinkedList.prototype.clear = function() {
      this._size = 0;
      this._head = new BDS.DoubleListNode(null, null, null);
      this._tail = new BDS.DoubleListNode(null, null, null);
      this._head.next = this._tail;
      return this._tail.prev = this._head;
    };

    DoubleLinkedList.prototype.isEmpty = function() {
      return this._size === 0;
    };

    DoubleLinkedList.prototype.size = function() {
      return this._size;
    };

    DoubleLinkedList.prototype.push_back = function(elem) {
      this._tail.data = elem;
      this._tail.next = new BDS.DoubleListNode(null, this._tail, null);
      this._tail = this._tail.next;
      this._size++;
    };

    DoubleLinkedList.prototype.pop_back = function() {
      var output;
      this._tail = this._tail.prev;
      this._tail.next.prev = null;
      this._tail.next = null;
      output = this._tail.data;
      this._tail.data = null;
      this._size--;
      return output;
    };

    DoubleLinkedList.prototype.push_front = function(elem) {
      this._head.data = elem;
      this._head.prev = new BDS.DoubleListNode(null, null, this._head);
      this._head = this._head.next;
      this._size++;
    };

    DoubleLinkedList.prototype.pop_front = function(elem) {
      var output;
      this._head = this._head.next;
      this._head.prev.next = null;
      this._head.prev = null;
      output = this._head.data;
      this._head.data = null;
      this._size--;
      return output;
    };

    DoubleLinkedList.prototype.add = function(elem) {
      this.push_back(elem);
    };

    DoubleLinkedList.prototype.push = function(elem) {
      this.push_back(elem);
    };

    DoubleLinkedList.prototype.pop = function(elem) {
      return this.pop_back();
    };

    DoubleLinkedList.prototype._remove = function(node) {
      if (node === this._head || node === this._tail) {
        throw new Error("Error: Do not attempt to remove the ending iterators, only use them to stop iteration.");
      }
      node.next.prev = node.prev;
      node.prev.next = node.next;
      this._size--;
    };

    DoubleLinkedList.prototype.append = function(array) {
      var e, i, len;
      for (i = 0, len = array.length; i < len; i++) {
        e = array[i];
        this.push_back(e);
      }
    };

    DoubleLinkedList.prototype.begin = function() {
      return new BDS.DoubleListIterator(this._head, this);
    };

    DoubleLinkedList.prototype.end = function() {
      return new BDS.DoubleListIterator(this._tail, this);
    };

    DoubleLinkedList.prototype.toString = function() {
      var iter, output, results;
      output = "";
      iter = this.iterator();
      results = [];
      while (iter.hasNext()) {
        results.push(output += iter.next());
      }
      return results;
    };

    return DoubleLinkedList;

  })();

  BDS.DoubleListNode = (function() {
    function DoubleListNode(data, prev, next) {
      this.data = data;
      this.prev = prev;
      this.next = next;
    }

    return DoubleListNode;

  })();

  BDS.DoubleListIterator = (function() {
    function DoubleListIterator(_node, _list) {
      this._node = _node;
      this._list = _list;
    }

    DoubleListIterator.prototype.hasNext = function() {
      return this._node.next.data !== null;
    };

    DoubleListIterator.prototype.hasPrev = function() {
      return this._node.prev.data !== null;
    };

    DoubleListIterator.prototype.next = function() {
      this._node = this._node.next;
      return this._node.data;
    };

    DoubleListIterator.prototype.prev = function() {
      this._node = this._node.prev;
      return this._node.data;
    };

    DoubleListIterator.prototype.current = function() {
      return this._node.data;
    };

    DoubleListIterator.prototype.remove = function() {
      return this._list._remove(this._node);
    };

    return DoubleListIterator;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Heap
Implements a priority Queue using an Array Heap.
Written by Bryce Summers on 11 - 2 - 2017.

 * 
 * Note : This is a MIN heap.
 * 
 * Heap property :  For every element in the tree,
 *                  it is less than or equal to its left and right children in the tree as defined by the elements at the indexes associated by
 *                  the relationships index_left(index) and index_right(index).
 *  
 * Root node is always at index 0.
 * 
 * Left biased, when equal keys are present, the one on the left will be chosen.
 * 
 * Allows for duplicate keys.
 * 
 * Binary tree invariants :
 * The heap is represented by a binary tree that is encoded by index relationships within an unbounded array.
 * We maintain the UBA with a minimality of nodes, so the UBA will only contain N elements, when size = n.
 * 
 * The heap is as balanced as possible. This causes their to be a preference for left children over right children.
 * 
 * FIXME : I will need to work to preserve key stability, so that all keys will eventually be deleted, even if all keys entered are equal.
 */

(function() {
  BDS.Heap = (function() {
    Heap._D = 3;

    function Heap(data_in, comparator) {
      this._LE = comparator;
      if (!data_in) {
        this._data = [];
      } else {
        this._data = data_in.slice(0);
        this._heapify();
      }
    }

    Heap.prototype.size = function() {
      return this._data.length;
    };

    Heap.prototype.isEmpty = function() {
      return this._data.length === 0;
    };

    Heap.prototype.add = function(elem) {
      var len;
      len = this._data.length;
      this._data.push(elem);
      return this._sift_up(len);
    };

    Heap.prototype.append = function(elems) {
      var e, j, len1, results;
      results = [];
      for (j = 0, len1 = elems.length; j < len1; j++) {
        e = elems[j];
        results.push(this.add(e));
      }
      return results;
    };

    Heap.prototype.peek = function() {
      return this._data[0];
    };

    Heap.prototype.dequeue = function() {
      var last, output;
      if (this._data.length === 1) {
        return this._data.pop();
      }
      output = this._data[0];
      last = this._data.pop();
      this._data[0] = last;
      this.sift_down(0);
      return output;
    };

    Heap.prototype.toArray = function() {
      return this._data.slice(0);
    };

    Heap.prototype.getElem = function(index) {
      return this._data[index];
    };


    /*
    // Heapifies all of the nodes of the Tree with a root at the given index.
    // Builds the heap invariant downwards to all sub trees.
    // O(n), checks each node in the tree once.
    // Transforms a random array into an array that meets the heap invariants.
     */

    Heap.prototype._heapify = function() {
      var i, j, ref;
      for (i = j = ref = this._data.length - 1; j >= 0; i = j += -1) {
        this.sift_down(i);
      }
    };


    /*
    // Given an index, swaps the node down the tree while maintaining the min
    // heap invariant until the node is in an invariant correct place.
    // O(log(n)). Non recursive, so has O(1) function calls.
    // SIFT down.
     */

    Heap.prototype.sift_down = function(index) {
      var child, child_index, elem, i, min_elem, min_elem_index, size;
      size = this._data.length;
      child_index = this._index_child(index, 1);
      elem = this._data[index];
      while (child_index < size) {
        min_elem_index = -1;
        min_elem = elem;
        i = child_index;
        while (i < child_index + BDS.Heap._D && i < size) {
          child = this._data[i];
          if (this._LE(child, min_elem)) {
            min_elem = child;
            min_elem_index = i;
          }
          i++;
        }
        if (min_elem === elem) {
          return;
        }
        this._min_first(index, min_elem_index);
        index = min_elem_index;
        child_index = this._index_child(index, 1);
      }
    };

    Heap.prototype._sift_up = function(index) {
      var parent_index, results;
      parent_index = this._index_parent(index);
      results = [];
      while (index > 0 && this._min_first(parent_index, index)) {
        index = parent_index;
        results.push(parent_index = this._index_parent(index));
      }
      return results;
    };

    Heap.prototype._index_parent = function(index) {
      return Math.floor((index - 1) / BDS.Heap._D);
    };

    Heap.prototype._index_child = function(index, child_index) {
      return BDS.Heap._D * index + child_index;
    };

    Heap.prototype._min_first = function(index1, index2) {
      var elem1, elem2;
      elem1 = this._data[index1];
      elem2 = this._data[index2];
      if (!this._LE(elem1, elem2)) {
        BDS.Arrays.swap(this._data, index1, index2);
        return true;
      }
      return false;
    };

    Heap.prototype.toString = function() {
      var elem, j, len1, output, ref;
      output = "";
      output += "\nMinHeap[";
      ref = this._data;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        elem = ref[j];
        output += elem;
        output += ",\n";
      }
      output += "]";
      return output;
    };

    Heap.prototype.clone = function() {
      return new BDS.Heap(this._data, this._LE);
    };

    Heap.prototype.toSortedArray = function() {
      var heap, i, j, len, output, ref;
      len = this._data.length;
      output = [];
      heap = this.clone();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        output.push(heap.dequeue());
      }
      return output;
    };

    Heap.prototype.clear = function() {
      return this._data = [];
    };

    return Heap;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Single Linked List Class
 * Written as part of the Bryce Summers Javascript Data Structures Libary.
 * Written by Bryce Summers on 6/12/2015.
 * Adapted by Bryce on 1 - 3 - 2017.

This should be used for more space efficient queues, stacks, or just iteration lists that support removal during iteration, such as in a game loop.
 */

(function() {
  BDS.SingleLinkedList = (function() {
    function SingleLinkedList() {
      this.clear();
    }

    SingleLinkedList.prototype.clear = function() {
      this._size = 0;
      this._head = new BDS.ListNode(null);
      return this._tail = this._head;
    };

    SingleLinkedList.prototype.push = function(elem) {
      var new_head;
      new_head = new BDS.ListNode(elem, this._head);
      this._head = new_head;
      return this.size++;
    };

    SingleLinkedList.prototype.pop = function() {
      var output;
      output = this._head.data;
      this._head = this._head.next;
      this._size--;
      return output;
    };

    SingleLinkedList.prototype.add = function(elem) {
      return this.push(elem);
    };

    SingleLinkedList.prototype.append = function(array) {
      var e, i, len, results;
      results = [];
      for (i = 0, len = array.length; i < len; i++) {
        e = array[i];
        results.push(this.push(e));
      }
      return results;
    };

    SingleLinkedList.prototype.remove_beginning = function() {
      return this.pop();
    };

    SingleLinkedList.prototype.enqueue = function(elem) {
      this._tail.data = elem;
      this._tail.next = new BDS.ListNode(null, null);
      this._tail = this._tail.next;
      return this._size++;
    };

    SingleLinkedList.prototype.dequeue = function() {
      return this.pop();
    };

    SingleLinkedList.prototype.iterator = function() {
      return new ListIterator(this._head, this);
    };

    SingleLinkedList.prototype.isEmpty = function() {
      return this.size === 0;
    };

    SingleLinkedList.prototype.size = function() {
      return this._size;
    };

    SingleLinkedList.prototype.toString = function() {
      var iter, output, results;
      output = "";
      iter = this.iterator();
      results = [];
      while (iter.hasNext()) {
        results.push(output += iter.next());
      }
      return results;
    };

    return SingleLinkedList;

  })();

  BDS.ListNode = (function() {
    function ListNode(data, next) {
      this.data = data;
      this.next = next;
    }

    return ListNode;

  })();

  BDS.ListIterator = (function() {
    function ListIterator(_node, _list) {
      this._node = _node;
      this._list = _list;
      this.last = this._node;
    }

    ListIterator.prototype.hasNext = function() {
      return this._node.next !== null;
    };

    ListIterator.prototype.next = function() {
      var output;
      output = this._node.data;
      this._last = this._node;
      this._node = this._node.next;
      return output;
    };

    ListIterator.prototype.remove = function() {

      /*
      Copy all of the next node's information over to the node that was just returned.
      thereby erasing and possibly releasing the memory.
       */
      this._last.data = this._node.data;
      this._last.next = this._node.next;
      if (this._node.next === null) {
        this._list.tail = this._last;
      }
      this._node = this._last;
      return this._list._size--;
    };

    return ListIterator;

  })();

}).call(this);
