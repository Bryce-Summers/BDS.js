/*! Bryce Data Structures, a project by Bryce Summers.
 *  Single File concatenated by Grunt Concatenate on 05-01-2017
 */
/*
 * Defines namespaces.
 * Adapted by Bryce Summers on 1 - 2 - 2017.
 */

// Bryce Data Structures.
BDS = {};
// Generated by CoffeeScript 1.11.1

/*
Standard Array methods.
 */

(function() {
  BDS.Arrays = {};

  BDS.Arrays.swap = function(array, i1, i2) {
    var temp;
    temp = array[i1];
    array[i1] = array[i2];
    array[i2] = temp;
  };

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Box.

Written by Bryce Summers on 1 - 5 - 2017
 */

(function() {
  BDS.Box = (function() {
    function Box(min, max) {
      this.min = min;
      this.max = max;
      if (!this.min) {
        this.min = new BDS.Point(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      }
      if (!this.max) {
        this.max = new BDS.Point(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
      }
    }

    Box.prototype.clone = function() {
      return new BDS.Box(this.min.clone(), this.max.clone());
    };

    Box.prototype.expandByPoint = function(p) {
      this.min = this.min.min(p);
      return this.max = this.max.max(p);
    };

    Box.prototype.union = function(box) {
      var out;
      out = this.clone();
      out.min = this.min.min(box.min);
      out.max = this.max.max(box.max);
      return out;
    };

    return Box;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  BDS.S_Curve = (function() {
    function S_Curve() {
      this._spline = new THREE.CatmullRomCurve3();
      this._point_discretization = [];
    }

    S_Curve.prototype.addPoint = function(p) {
      return this._spline.points.push(p);
    };

    S_Curve.prototype.numPoints = function(p) {
      return this._spline.points.length;
    };

    S_Curve.prototype.getPointAtIndex = function(i) {
      return this._spline.points[i];
    };

    S_Curve.prototype.getLastPoint = function() {
      return this.getPointAtIndex(this.numPoints() - 1);
    };

    S_Curve.prototype.removeLastPoint = function() {
      return this._spline.points.pop();
    };

    S_Curve.prototype.position = function(t) {
      return this._spline.getPoint(t);
    };

    S_Curve.prototype.tangent = function(t) {
      return this._spline.getTangent(t);
    };

    S_Curve.prototype.offset = function(t, amount) {
      var tan, x, y;
      tan = this.tangent(t);
      tan.setLength(amount);
      x = tan.x;
      y = tan.y;
      tan.x = y;
      tan.y = -x;
      return this.position(t).add(tan);
    };

    S_Curve.prototype.getDiscretization = function(max_length) {
      return this._discretization;
    };

    S_Curve.prototype.updateDiscretization = function(max_length) {
      var S, high, low, output, p0, p_high, p_low;
      output = [];
      p0 = this._spline.getPoint(0);
      output.push(p0);
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this._spline.getPoint(low);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this._spline.getPoint(high);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this._spline.getPoint(high);
        }
        output.push(p_high);
        low = high;
        p_low = p_high;
        continue;
      }
      return this._discretization = output;
    };

    S_Curve.prototype.getOffsets = function(max_length, amount, times_output) {
      var S, high, low, o0, output, p_high, p_low;
      o0 = this.offset(0, amount);
      output = [];
      output.push(o0);
      if (times_output) {
        times_output.push(0);
      }
      S = [];
      S.push(1.0);
      low = 0;
      p_low = this.offset(low, amount);
      while (S.length !== 0) {
        high = S.pop();
        p_high = this.offset(high, amount);
        while (p_low.distanceTo(p_high) > max_length) {
          S.push(high);
          high = (low + high) / 2.0;
          p_high = this.offset(high, amount);
        }
        output.push(p_high);
        if (times_output) {
          times_output.push(high);
        }
        low = high;
        p_low = p_high;
        continue;
      }
      return output;
    };

    return S_Curve;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Point.

Written by Bryce Summers on 1 - 2 - 2017.

Implements Arithmetic.

add, sub, multScalar
 */

(function() {
  BDS.Point = (function() {
    function Point(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      if (!this.z) {
        this.z = 0.0;
      }
    }

    Point.prototype.clone = function() {
      return new BDS.Point(this.x, this.y, this.z);
    };

    Point.prototype.add = function(pt) {
      var out;
      out = this.clone();
      out.x += pt.x;
      out.y += pt.y;
      out.z += pt.z;
      return out;
    };

    Point.prototype.sub = function(pt) {
      var out;
      out = this.clone();
      out.x -= pt.x;
      out.y -= pt.y;
      out.z -= pt.z;
      return out;
    };

    Point.prototype.multScalar = function(s) {
      var out;
      out = this.clone();
      out.x *= s;
      out.y *= s;
      out.z *= s;
      return out;
    };

    Point.prototype.divScalar = function(s) {
      var out;
      out = this.clone();
      out.x /= s;
      out.y /= s;
      out.z /= s;
      return out;
    };

    Point.prototype.toString = function() {
      var output;
      output = "Point(" + this.x + ", " + this.y;
      if (this.z) {
        output += ", " + this.z;
      }
      output += ")";
      return output;
    };

    Point.prototype.magnitude = function() {
      return this.norm();
    };

    Point.prototype.norm = function() {
      return Math.sqrt(this.norm2());
    };

    Point.prototype.norm2 = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };

    Point.prototype.min = function(pt) {
      var out;
      out = this.clone();
      out.x = Math.min(this.x, pt.x);
      out.y = Math.min(this.y, pt.y);
      out.z = Math.min(this.z, pt.z);
      return out;
    };

    Point.prototype.max = function(pt) {
      var out;
      out = this.clone();
      out.x = Math.max(this.x, pt.x);
      out.y = Math.max(this.y, pt.y);
      out.z = Math.max(this.z, pt.z);
      return out;
    };

    return Point;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Polyline class

Written by Bryce Summers on 1 - 4 - 2017.

Note: Closed Polylines are polygons...
 - So we will put all of our polygon code into this class.
 */

(function() {
  BDS.Polyline = (function() {
    function Polyline(_isClosed, points_in) {
      this._isClosed = _isClosed;
      if (this._isClosed === void 0) {
        this._isClosed = false;
      }
      this._points = [];
      if (points_in) {
        this.appendPoints(points_in);
      }
      this._boundingbox = null;
    }

    Polyline.prototype.appendPoints = function(array) {
      var j, len1, p, results;
      results = [];
      for (j = 0, len1 = array.length; j < len1; j++) {
        p = array[j];
        results.push(this.addPoint(p));
      }
      return results;
    };

    Polyline.prototype.addPoint = function(p) {
      return this._points.push(p);
    };

    Polyline.prototype.removeLastPoint = function() {
      return this._points.pop();
    };

    Polyline.prototype.getPoint = function(index) {
      return this._points[index];
    };

    Polyline.prototype.size = function() {
      return this._points.length;
    };

    Polyline.prototype.isClosed = function() {
      return this._isClosed;
    };


    /*
    * http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/
    * Computes the area of a 2D polygon directly from the polygon's coordinates.
    * The area will be positive or negative depending on the
    * clockwise / counter clockwise orientation of the points.
    * Also see: https://brycesummers.wordpress.com/2015/08/24/a-proof-of-simple-polygonal-area-via-greens-theorem/
    * Note: This function interprets this polyline as closed.
     *  -> float
     */

    Polyline.prototype.computeArea = function() {
      var area, i, j, len, p1, p2, ref;
      len = this._points.length;
      p1 = this._points[len - 1];
      area = 0.0;
      for (i = j = 0, ref = len; j < ref; i = j += 1) {
        p2 = this._points[i];
        area += (p2.x + p1.x) * (p2.y - p1.y);
        p1 = p2;
      }
      return area / 2.0;
    };

    Polyline.prototype.isComplemented = function() {
      return this.computeArea() > 0;
    };

    Polyline.prototype.setBoundingBox = function(box) {
      return this._boundingbox = box;
    };

    Polyline.prototype.getBoundingBox = function() {
      return this._boundingbox;
    };

    return Polyline;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1
(function() {
  BDS.BVH2D = (function() {
    function BVH2D(polygons, xy) {
      var i, j, left_partition, ref, ref1, right_partition;
      if (!xy) {
        xy = {
          val: 'x'
        };
      }
      this._leafs = [];
      this._leaf_node = false;
      this._ensure_bounding_boxes(polygons);
      this._AABB = this._compute_AABB(polygons);
      if (polygons.length < 4) {
        this._leaf_node = true;
        for (i = j = 0, ref = polygons.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          this._leafs.push(polygons[i]);
        }
        return;
      }
      if (xy.dim === 2) {
        this._AABB.min.z = -1;
        this._AABB.max.z = +1;
      }
      polygons = this._sort_polygon_list(polygons, xy);
      ref1 = this._partition_by_SA(polygons), left_partition = ref1[0], right_partition = ref1[1];
      xy.val = this._nextXY(xy);
      this._left = new BDS.BVH2D(left_partition, xy);
      this._right = new BDS.BVH2D(right_partition, xy);
    }


    /*
     - Private Construction Methods. -----------------------
     */

    BVH2D.prototype._sort_polygon_list = function(polygon_list, xy) {
      var centroid_index_list, i, j, len, output, polygon_index, ref, sort_function;
      centroid_index_list = this._centroid_index_list(polygon_list);
      sort_function = function(a, b) {
        switch (xy.val) {
          case 'x':
            return a.centroid.x - b.centroid.x;
          case 'y':
            return a.centroid.y - b.centroid.y;
        }
        debugger;
        return console.log("xy is malformed.");
      };
      centroid_index_list.sort(sort_function);
      output = [];
      len = polygon_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon_index = centroid_index_list[i].index;
        output.push(polygon_list[polygon_index]);
      }
      return output;
    };

    BVH2D.prototype._nextXY = function(xy) {
      switch (xy.val) {
        case 'x':
          return 'y';
        case 'y':
          return 'x';
      }
      debugger;
      console.log("xy is malformed.");
      debugger;
      return console.log("Case not handled.");
    };

    BVH2D.prototype._centroid_index_list = function(polygon_list) {
      var centroid_index_node, i, j, len, output, ref;
      output = [];
      len = polygon_list.length;
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        centroid_index_node = {};
        centroid_index_node.index = i;
        centroid_index_node.centroid = this._computeCentroid(polygon_list[i]);
        output.push(centroid_index_node);
      }
      return output;
    };

    BVH2D.prototype._computeCentroid = function(polygon) {
      var centroid, i, j, len, point, ref;
      centroid = new BDS.Point(0, 0);
      len = polygon.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        point = polygon.getPoint(i);
        centroid = centroid.add(point);
      }
      return centroid.divScalar(len);
    };

    BVH2D.prototype._partition_by_SA = function(polygon_list) {
      var i, i0, j, k, l, left, left_AABB, m, min_index, min_sah, ref, ref1, ref2, ref3, ref4, right, right_AABB, sah, sah_left, sah_right;
      min_sah = Number.MAX_VALUE;
      min_index = -1;
      left = [polygon_list[0]];
      right = [];
      i0 = polygon_list.length - 1;
      for (i = j = ref = i0; ref <= 1 ? j <= 1 : j >= 1; i = ref <= 1 ? ++j : --j) {
        right.push(polygon_list[i]);
      }
      for (i = k = 1, ref1 = i0; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
        left_AABB = this._compute_AABB(left);
        sah_left = this._compute_SA(left_AABB);
        right_AABB = this._compute_AABB(right);
        sah_right = this._compute_SA(right_AABB);
        sah = Math.max(sah_left, sah_right);
        if (sah < min_sah) {
          min_sah = sah;
          min_index = i;
        }
        left.push(right.pop());
      }
      left = [];
      right = [];
      for (i = l = 0, ref2 = min_index; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        left.push(polygon_list[i]);
      }
      for (i = m = ref3 = min_index, ref4 = i0; ref3 <= ref4 ? m <= ref4 : m >= ref4; i = ref3 <= ref4 ? ++m : --m) {
        right.push(polygon_list[i]);
      }
      return [left, right];
    };

    BVH2D.prototype._ensure_bounding_boxes = function(polygon_list) {
      var err, i, j, len, polygon, ref, results;
      len = polygon_list.length;
      results = [];
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon = polygon_list[i];
        if (!polygon) {
          err = new Error();
          console.log(err.stack);
          debugger;
          throw new Error("BSD.BVH: Polygon is missing a bounding box.");
        }
        if (!polygon.boundingBox) {
          results.push(this._computeBoundingBox(polygon));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    BVH2D.prototype._computeBoundingBox = function(polygon) {
      var AABB, i, j, len, pt, ref;
      AABB = new BDS.Box();
      len = polygon.size();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        pt = polygon.getPoint(i);
        AABB.expandByPoint(pt);
      }
      return polygon.setBoundingBox(AABB);
    };

    BVH2D.prototype._compute_AABB = function(polygon_list) {
      var AABB, i, j, output, polygon, ref;
      output = new BDS.Box();
      for (i = j = 0, ref = polygon_list.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        polygon = polygon_list[i];
        AABB = polygon.getBoundingBox();
        output = output.union(AABB);
      }
      return output;
    };

    BVH2D.prototype._compute_SA = function(AABB) {
      var dx, dy, dz, max, min, sxy, sxz, syz;
      min = AABB.min;
      max = AABB.max;
      dx = max.x - min.x;
      dy = max.y - min.y;
      dz = max.z - min.z;
      sxy = dx * dy;
      sxz = dx * dz;
      syz = dy * dz;
      return sxy + sxz + syz;
    };

    BVH2D.prototype.query_point = function(x, y) {
      debugger;
      var ray;
      throw new Error("FIXME");
      ray = new THREE.Ray(new THREE.Vector3(x, y, 10), new THREE.Vector3(0, 0, 1));
      return this.query_ray(ray);
    };

    BVH2D.prototype.toPolylines = function() {
      var polylines;
      polylines = [];
      this._toPolylines(polylines);
      return polylines;
    };

    BVH2D.prototype._toPolylines = function(output) {
      var max, max_x, max_y, min, min_x, min_y, p0, p1, p2, p3, polyline;
      min = this._AABB.min;
      max = this._AABB.max;
      min_x = min.x;
      min_y = min.y;
      max_x = max.x;
      max_y = max.y;
      p0 = new BDS.Point(min_x, min_y, 0);
      p1 = new BDS.Point(max_x, min_y, 0);
      p2 = new BDS.Point(max_x, max_y, 0);
      p3 = new BDS.Point(min_x, max_y, 0);
      polyline = new BDS.Polyline(true, [p0, p1, p2, p3]);
      output.push(polyline);
      if (!this._leaf_node) {
        this._left._toPolylines(output);
        this._right._toPolylines(output);
      }
    };

    return BVH2D;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Double Linked List Class
 * Written as part of the Bryce Summers Javascript Data Structures Libary.
 * Written by Bryce Summers on 1/3/2017.
 */

(function() {
  BDS.DoubleLinkedList = (function() {
    function DoubleLinkedList() {
      this.clear();
    }

    DoubleLinkedList.prototype.clear = function() {
      this._size = 0;
      this._head = new BDS.DoubleListNode(null, null, null);
      this._tail = new BDS.DoubleListNode(null, null, null);
      this._head.next = this._tail;
      return this._tail.prev = this._head;
    };

    DoubleLinkedList.prototype.isEmpty = function() {
      return this._size === 0;
    };

    DoubleLinkedList.prototype.size = function() {
      return this._size;
    };

    DoubleLinkedList.prototype.push_back = function(elem) {
      this._tail.data = elem;
      this._tail.next = new BDS.DoubleListNode(null, this._tail, null);
      this._tail = this._tail.next;
      this._size++;
    };

    DoubleLinkedList.prototype.pop_back = function() {
      var output;
      this._tail = this._tail.prev;
      this._tail.next.prev = null;
      this._tail.next = null;
      output = this._tail.data;
      this._tail.data = null;
      this._size--;
      return output;
    };

    DoubleLinkedList.prototype.push_front = function(elem) {
      this._head.data = elem;
      this._head.prev = new BDS.DoubleListNode(null, null, this._head);
      this._head = this._head.next;
      this._size++;
    };

    DoubleLinkedList.prototype.pop_front = function(elem) {
      var output;
      this._head = this._head.next;
      this._head.prev.next = null;
      this._head.prev = null;
      output = this._head.data;
      this._head.data = null;
      this._size--;
      return output;
    };

    DoubleLinkedList.prototype.add = function(elem) {
      this.push_back(elem);
    };

    DoubleLinkedList.prototype.push = function(elem) {
      this.push_back(elem);
    };

    DoubleLinkedList.prototype.pop = function(elem) {
      return this.pop_back();
    };

    DoubleLinkedList.prototype._remove = function(node) {
      if (node === this._head || node === this._tail) {
        throw new Error("Error: Do not attempt to remove the ending iterators, only use them to stop iteration.");
      }
      node.next.prev = node.prev;
      node.prev.next = node.next;
    };

    DoubleLinkedList.prototype.append = function(array) {
      var e, i, len;
      for (i = 0, len = array.length; i < len; i++) {
        e = array[i];
        this.push_back(e);
      }
    };

    DoubleLinkedList.prototype.begin = function() {
      return new BDS.DoubleListIterator(this._head, this);
    };

    DoubleLinkedList.prototype.end = function() {
      return new BDS.DoubleListIterator(this._tail, this);
    };

    DoubleLinkedList.prototype.toString = function() {
      var iter, output, results;
      output = "";
      iter = this.iterator();
      results = [];
      while (iter.hasNext()) {
        results.push(output += iter.next());
      }
      return results;
    };

    return DoubleLinkedList;

  })();

  BDS.DoubleListNode = (function() {
    function DoubleListNode(data, prev, next) {
      this.data = data;
      this.prev = prev;
      this.next = next;
    }

    return DoubleListNode;

  })();

  BDS.DoubleListIterator = (function() {
    function DoubleListIterator(_node, _list) {
      this._node = _node;
      this._list = _list;
    }

    DoubleListIterator.prototype.hasNext = function() {
      return this._node.next.data !== null;
    };

    DoubleListIterator.prototype.hasPrev = function() {
      return this._node.prev.data !== null;
    };

    DoubleListIterator.prototype.next = function() {
      this._node = this._node.next;
      return this._node.data;
    };

    DoubleListIterator.prototype.prev = function() {
      this._node = this._node.prev;
      return this._node.data;
    };

    DoubleListIterator.prototype.current = function() {
      return this._node.data;
    };

    DoubleListIterator.prototype.remove = function() {
      return this._list._remove(this._node);
    };

    return DoubleListIterator;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
Heap
Implements a priority Queue using an Array Heap.
Written by Bryce Summers on 11 - 2 - 2017.

 * 
 * Note : This is a MIN heap.
 * 
 * Heap property :  For every element in the tree,
 *                  it is less than or equal to its left and right children in the tree as defined by the elements at the indexes associated by
 *                  the relationships index_left(index) and index_right(index).
 *  
 * Root node is always at index 0.
 * 
 * Left biased, when equal keys are present, the one on the left will be chosen.
 * 
 * Allows for duplicate keys.
 * 
 * Binary tree invariants :
 * The heap is represented by a binary tree that is encoded by index relationships within an unbounded array.
 * We maintain the UBA with a minimality of nodes, so the UBA will only contain N elements, when size = n.
 * 
 * The heap is as balanced as possible. This causes their to be a preference for left children over right children.
 * 
 * FIXME : I will need to work to preserve key stability, so that all keys will eventually be deleted, even if all keys entered are equal.
 */

(function() {
  BDS.Heap = (function() {
    Heap._D = 3;

    function Heap(data_in, comparator) {
      this._LE = comparator;
      if (!data_in) {
        this._data = [];
      } else {
        this._data = data_in.slice(0);
        this._heapify();
      }
    }

    Heap.prototype.size = function() {
      return this._data.length;
    };

    Heap.prototype.isEmpty = function() {
      return this._data.length === 0;
    };

    Heap.prototype.add = function(elem) {
      var len;
      len = this._data.length;
      this._data.push(elem);
      return this._sift_up(len);
    };

    Heap.prototype.append = function(elems) {
      var e, j, len1, results;
      results = [];
      for (j = 0, len1 = elems.length; j < len1; j++) {
        e = elems[j];
        results.push(this.add(e));
      }
      return results;
    };

    Heap.prototype.peek = function() {
      return this._data[0];
    };

    Heap.prototype.dequeue = function() {
      var last, output;
      if (this._data.length === 1) {
        return this._data.pop();
      }
      output = this._data[0];
      last = this._data.pop();
      this._data[0] = last;
      this.sift_down(0);
      return output;
    };

    Heap.prototype.toArray = function() {
      return this._data.slice(0);
    };

    Heap.prototype.getElem = function(index) {
      return this._data[index];
    };


    /*
    // Heapifies all of the nodes of the Tree with a root at the given index.
    // Builds the heap invariant downwards to all sub trees.
    // O(n), checks each node in the tree once.
    // Transforms a random array into an array that meets the heap invariants.
     */

    Heap.prototype._heapify = function() {
      var i, j, ref;
      for (i = j = ref = this._data.length - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
        this.sift_down(i);
      }
    };


    /*
    // Given an index, swaps the node down the tree while maintaining the min
    // heap invariant until the node is in an invariant correct place.
    // O(log(n)). Non recursive, so has O(1) function calls.
    // SIFT down.
     */

    Heap.prototype.sift_down = function(index) {
      var child, child_index, elem, i, min_elem, min_elem_index, size;
      size = this._data.length;
      child_index = this._index_child(index, 1);
      elem = this._data[index];
      while (child_index < size) {
        min_elem_index = -1;
        min_elem = elem;
        i = child_index;
        while (i < child_index + BDS.Heap._D && i < size) {
          child = this._data[i];
          if (this._LE(child, min_elem)) {
            min_elem = child;
            min_elem_index = i;
          }
          i++;
        }
        if (min_elem === elem) {
          return;
        }
        this._min_first(index, min_elem_index);
        index = min_elem_index;
        child_index = this._index_child(index, 1);
      }
    };

    Heap.prototype._sift_up = function(index) {
      var parent_index, results;
      parent_index = this._index_parent(index);
      results = [];
      while (index > 0 && this._min_first(parent_index, index)) {
        index = parent_index;
        results.push(parent_index = this._index_parent(index));
      }
      return results;
    };

    Heap.prototype._index_parent = function(index) {
      return Math.floor((index - 1) / BDS.Heap._D);
    };

    Heap.prototype._index_child = function(index, child_index) {
      return BDS.Heap._D * index + child_index;
    };

    Heap.prototype._min_first = function(index1, index2) {
      var elem1, elem2;
      elem1 = this._data[index1];
      elem2 = this._data[index2];
      if (!this._LE(elem1, elem2)) {
        BDS.Arrays.swap(this._data, index1, index2);
        return true;
      }
      return false;
    };

    Heap.prototype.toString = function() {
      var elem, j, len1, output, ref;
      output = "";
      output += "\nMinHeap[";
      ref = this._data;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        elem = ref[j];
        output += elem;
        output += ",\n";
      }
      output += "]";
      return output;
    };

    Heap.prototype.clone = function() {
      return new BDS.Heap(this._data, this._LE);
    };

    Heap.prototype.toSortedArray = function() {
      var heap, i, j, len, output, ref;
      len = this._data.length;
      output = [];
      heap = this.clone();
      for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        output.push(heap.dequeue());
      }
      return output;
    };

    Heap.prototype.clear = function() {
      return this._data = [];
    };

    return Heap;

  })();

}).call(this);

// Generated by CoffeeScript 1.11.1

/*
 * Single Linked List Class
 * Written as part of the Bryce Summers Javascript Data Structures Libary.
 * Written by Bryce Summers on 6/12/2015.
 * Adapted by Bryce on 1 - 3 - 2017.

This should be used for more space efficient queues, stacks, or just iteration lists that support removal during iteration, such as in a game loop.
 */

(function() {
  BDS.SingleLinkedList = (function() {
    function SingleLinkedList() {
      this.clear();
    }

    SingleLinkedList.prototype.clear = function() {
      this._size = 0;
      this._head = new BDS.ListNode(null);
      return this._tail = this._head;
    };

    SingleLinkedList.prototype.push = function(elem) {
      var new_head;
      new_head = new BDS.ListNode(elem, this._head);
      this._head = new_head;
      return this.size++;
    };

    SingleLinkedList.prototype.pop = function() {
      var output;
      output = this._head.data;
      this._head = this._head.next;
      this._size--;
      return output;
    };

    SingleLinkedList.prototype.add = function(elem) {
      return this.push(elem);
    };

    SingleLinkedList.prototype.append = function(array) {
      var e, i, len, results;
      results = [];
      for (i = 0, len = array.length; i < len; i++) {
        e = array[i];
        results.push(this.push(e));
      }
      return results;
    };

    SingleLinkedList.prototype.remove_beginning = function() {
      return this.pop();
    };

    SingleLinkedList.prototype.enqueue = function(elem) {
      this._tail.data = elem;
      this._tail.next = new BDS.ListNode(null, null);
      this._tail = this._tail.next;
      return this._size++;
    };

    SingleLinkedList.prototype.dequeue = function() {
      return this.pop();
    };

    SingleLinkedList.prototype.iterator = function() {
      return new ListIterator(this._head, this);
    };

    SingleLinkedList.prototype.isEmpty = function() {
      return this.size === 0;
    };

    SingleLinkedList.prototype.size = function() {
      return this._size;
    };

    SingleLinkedList.prototype.toString = function() {
      var iter, output, results;
      output = "";
      iter = this.iterator();
      results = [];
      while (iter.hasNext()) {
        results.push(output += iter.next());
      }
      return results;
    };

    return SingleLinkedList;

  })();

  BDS.ListNode = (function() {
    function ListNode(data, next) {
      this.data = data;
      this.next = next;
    }

    return ListNode;

  })();

  BDS.ListIterator = (function() {
    function ListIterator(_node, _list) {
      this._node = _node;
      this._list = _list;
      this.last = this._node;
    }

    ListIterator.prototype.hasNext = function() {
      return this._node.next !== null;
    };

    ListIterator.prototype.next = function() {
      var output;
      output = this._node.data;
      this._last = this._node;
      this._node = this._node.next;
      return output;
    };

    ListIterator.prototype.remove = function() {

      /*
      Copy all of the next node's information over to the node that was just returned.
      thereby erasing and possibly releasing the memory.
       */
      this._last.data = this._node.data;
      this._last.next = this._node.next;
      if (this._node.next === null) {
        this._list.tail = this._last;
      }
      this._node = this._last;
      return this._list._size--;
    };

    return ListIterator;

  })();

}).call(this);
